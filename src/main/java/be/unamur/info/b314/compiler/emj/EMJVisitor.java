package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJLexer;
import be.unamur.info.b314.compiler.EMJParser;
import be.unamur.info.b314.compiler.EMJParserBaseVisitor;
import be.unamur.info.b314.compiler.emj.EMJError;
import be.unamur.info.b314.compiler.emj.EMJErrorLogger;
import be.unamur.info.b314.compiler.emj.EMJSymbolTable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
 * Implements the visitor pattern to traverse AST and perform semantic analysis
 * 
 * @author : Alix Decrop
 * @version : 1.0
 */
public class EMJVisitor extends EMJParserBaseVisitor<Object> {

    private EMJErrorLogger errorLogger;
    private EMJSymbolTable symbolTable;
    private String currentScope; // Keeps track of the current function scope

    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
        this.currentScope = "global";
    }

    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }
    
    /**
     * Visit the root node of the AST
     * Entry point for the visitor pattern
     */
    @Override
    public Object visitRoot(EMJParser.RootContext ctx) {
        System.out.println("Visiting program root...");
        
        // Visit child nodes (either mapFile or programFile)
        return visitChildren(ctx);
    }
    
    /**
     * Visit the program file node which contains the main structure of an EMJ program
     */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx) {
        System.out.println("Visiting program file...");
        
        // Process the import statement if it exists
        if (ctx.importStatement() != null) {
            visit(ctx.importStatement());
        }
        
        // Visit main function (required)
        visit(ctx.mainFunction());
        
        // Visit all function declarations
        for (EMJParser.FunctionDeclContext funcCtx : ctx.functionDecl()) {
            visit(funcCtx);
        }
        
        // Visit any statements at global scope
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        return null;
    }
    
    /**
     * Visit import statement that imports a map file
     */
    @Override
    public Object visitImportStatement(EMJParser.ImportStatementContext ctx) {
        System.out.println("Visiting import statement: " + ctx.STRING_VALUE().getText());
        // Process the map file import - in a full implementation, this would verify the map file exists
        return null;
    }
    
    /**
     * Visit the main function declaration
     */
    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {
        System.out.println("Visiting main function...");
        
        // Set current scope to main for symbol table tracking
        String previousScope = this.currentScope;
        this.currentScope = "main";
        
        // Create a new scope in the symbol table for the main function
        this.symbolTable.enterScope("main");
        
        // Visit all statements in the main function body
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        // Exit the scope when done with main function
        this.symbolTable.exitScope();
        this.currentScope = previousScope;
        
        return null;
    }
    
    /**
     * Visit a function declaration
     */
    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        String funcId = ctx.EMOJI_ID().getText();
        System.out.println("Visiting function declaration: " + funcId);
        
        // Get the return type of the function
        String returnType = "VOID";
        if (ctx.returnType().type() != null) {
            returnType = getTypeFromContext(ctx.returnType().type());
        }
        
        // Add function to symbol table
        // In a real implementation, we would also store parameter types
        this.symbolTable.addFunction(funcId, returnType);
        
        // Store current scope to restore it later
        String previousScope = this.currentScope;
        this.currentScope = funcId;
        
        // Create a new scope for the function
        this.symbolTable.enterScope(funcId);
        
        // Process parameters if they exist
        if (ctx.optionalParamList().paramList() != null) {
            visit(ctx.optionalParamList());
        }
        
        // Visit all statements in the function body
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        // Visit the return statement
        visit(ctx.returnStatement());
        
        // Exit the function scope
        this.symbolTable.exitScope();
        this.currentScope = previousScope;
        
        return null;
    }
    
    /**
     * Visit parameter list in function declaration
     */
    @Override
    public Object visitOptionalParamList(EMJParser.OptionalParamListContext ctx) {
        // If no parameters, nothing to do
        if (ctx.paramList() == null) {
            return null;
        }
        
        // Visit the parameter list
        return visit(ctx.paramList());
    }
    
    /**
     * Visit parameter list and process each parameter
     */
    @Override
    public Object visitParamList(EMJParser.ParamListContext ctx) {
        // Visit each parameter in the list
        for (EMJParser.ParamContext paramCtx : ctx.param()) {
            visit(paramCtx);
        }
        
        return null;
    }
    
    /**
     * Visit a single parameter in a function declaration
     */
    @Override
    public Object visitParam(EMJParser.ParamContext ctx) {
        String paramId = ctx.EMOJI_ID().getText();
        String paramType = getTypeFromContext(ctx.type());
        
        // Add parameter to symbol table for current function scope
        // Parameters are initialized by definition
        this.symbolTable.addVariable(paramId, paramType, true);
        
        return null;
    }
    
    /**
     * Visit a statement node in the AST
     */
    @Override
    public Object visitStatement(EMJParser.StatementContext ctx) {
        System.out.println("Visiting statement...");
        
        // Delegate to the appropriate visit method based on the type of statement
        return visitChildren(ctx);
    }
    
    /**
     * Visit a return statement
     */
    @Override
    public Object visitReturnStatement(EMJParser.ReturnStatementContext ctx) {
        System.out.println("Visiting return statement...");
        
        // Handle different return statement types
        if (ctx.expression() != null) {
            // Return with expression - check type compatibility with function return type
            visit(ctx.expression());
            
            // In a full implementation, we would verify that the expression type
            // matches the function's declared return type
        }
        
        return null;
    }
    
    /**
     * Visit an if statement
     */
    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {
        System.out.println("Visiting if statement...");
        
        // Visit the condition expression
        visit(ctx.expression());
        
        // In a full implementation, we would verify that the condition is a boolean expression
        
        // Visit the true branch (required)
        visit(ctx.block(0));
        
        // Visit the else branch if it exists
        if (ctx.block().size() > 1) {
            visit(ctx.block(1));
        }
        
        return null;
    }
    
    /**
     * Visit a loop statement (while or for)
     */
    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {
        System.out.println("Visiting loop statement...");
        
        // Visit the condition expression
        visit(ctx.expression());
        
        // In a full implementation, we would verify that the condition is a boolean expression
        
        // Visit the loop body
        visit(ctx.block());
        
        return null;
    }
    
    /**
     * Visit a block of statements
     */
    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {
        // Visit each statement in the block
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        return null;
    }

    /**
     * Visit a variable declaration statement
     * SEMANTIC_VAR_DECL
     */
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {
        System.out.println("Visiting variable declaration: " + ctx.EMOJI_ID().getText());

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", 
                "Variable " + varId + " already exists", ctx.start.getLine()));
            return null;
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        
        // If there's an initializing expression, visit it to validate it
        if (isInitialized) {
            visit(ctx.expression());
            // In a full implementation, we would verify type compatibility between
            // the declared variable type and the expression result type
        }
        
        this.symbolTable.addVariable(varId, varType, isInitialized);

        return null;
    }

    /**
     * Get the data type from a type context
     * 
     * @param typeCtx The type context from the parser
     * @return The string representation of the type
     */
    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        } else if (typeCtx.tupleType() != null) {
            return "TUPLE";
        }

        return "UNKNOWN";
    }
    
    /**
     * Visit assignment statement
     */
    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        System.out.println("Visiting assignment...");
        
        // Visit the left expression (variable being assigned to)
        visit(ctx.leftExpression());
        
        // Visit the right expression (value being assigned)
        visit(ctx.expression());
        
        // In a full implementation, we would verify type compatibility
        // between the left expression and the right expression
        
        return null;
    }
    
    /**
     * Visit left expression (target of assignment)
     */
    @Override
    public Object visitLeftExpression(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        
        // Verify that the variable exists in the symbol table
        EMJSymbolInfo info = symbolTable.lookup(varId);
        if (info == null) {
            errorLogger.addError(new EMJError("varIdNotDecl", 
                "Variable " + varId + " not declared", ctx.start.getLine()));
        }
        
        // Check for tuple access
        boolean hasTupleAccess = ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null;
        if (hasTupleAccess && info != null) {
            // In a full implementation, we would verify that the variable is actually a tuple
            // and report an error if it's not
        }
        
        return null;
    }
    
    /**
     * Visit function call
     */
    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String funcId = ctx.EMOJI_ID().getText();
        System.out.println("Visiting function call: " + funcId);
        
        // Verify that the function exists in the symbol table
        EMJSymbolInfo info = symbolTable.lookup(funcId);
        if (info == null) {
            errorLogger.addError(new EMJError("funcIdNotDecl", 
                "Function " + funcId + " not declared", ctx.start.getLine()));
            return null;
        }
        
        // Visit arguments if they exist
        if (ctx.argumentList() != null) {
            visit(ctx.argumentList());
            
            // In a full implementation, we would verify argument count and types
        }
        
        return null;
    }
    
    /**
     * Visit argument list in a function call
     */
    @Override
    public Object visitArgumentList(EMJParser.ArgumentListContext ctx) {
        // Visit each argument expression
        for (EMJParser.ExpressionContext exprCtx : ctx.expression()) {
            visit(exprCtx);
        }
        
        return null;
    }
    
    /**
     * Visit an expression
     */
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Delegate to child expression (orExpression)
        return visitChildren(ctx);
    }
    
    /**
     * Visit an or expression (OR operator)
     */
    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // Visit the first and expression
        visit(ctx.andExpression(0));
        
        // Visit any additional and expressions if they exist (separated by OR)
        for (int i = 1; i < ctx.andExpression().size(); i++) {
            visit(ctx.andExpression(i));
        }
        
        // In a full implementation, we would verify that all expressions are boolean type
        
        return null;
    }
    
    /**
     * Visit an and expression (AND operator)
     */
    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // Visit the first not expression
        visit(ctx.notExpression(0));
        
        // Visit any additional not expressions if they exist (separated by AND)
        for (int i = 1; i < ctx.notExpression().size(); i++) {
            visit(ctx.notExpression(i));
        }
        
        // In a full implementation, we would verify that all expressions are boolean type
        
        return null;
    }
    
    /**
     * Visit a not expression (NOT operator)
     */
    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // Visit the comparison expression
        visit(ctx.comparisonExpression());
        
        // Check if NOT operator is present
        boolean hasNotOperator = ctx.NOT() != null;
        if (hasNotOperator) {
            // In a full implementation, we would verify that the expression is boolean type
        }
        
        return null;
    }
    
    /**
     * Visit a comparison expression (==, !=, <, <=, >, >=)
     */
    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // Visit the first additive expression
        visit(ctx.additiveExpression(0));
        
        // If there's a comparison operator, visit the second additive expression
        if (ctx.additiveExpression().size() > 1) {
            visit(ctx.additiveExpression(1));
            
            // In a full implementation, we would check type compatibility for comparison
        }
        
        return null;
    }
    
    /**
     * Visit an additive expression (+, -)
     */
    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // Visit the first multiplicative expression
        visit(ctx.multiplicativeExpression(0));
        
        // Visit any additional multiplicative expressions (separated by + or -)
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            visit(ctx.multiplicativeExpression(i));
            
            // In a full implementation, we would check type compatibility for addition/subtraction
        }
        
        return null;
    }
    
    /**
     * Visit a multiplicative expression (*, /)
     */
    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        // Visit the first unary expression
        visit(ctx.unaryExpression(0));
        
        // Visit any additional unary expressions (separated by * or /)
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            visit(ctx.unaryExpression(i));
            
            // In a full implementation, we would check type compatibility for multiplication/division
        }
        
        return null;
    }
    
    /**
     * Visit a unary expression (unary minus)
     */
    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // Visit the primary expression
        visit(ctx.primaryExpression());
        
        // Check if unary minus is present
        boolean hasUnaryMinus = ctx.MINUS() != null;
        if (hasUnaryMinus) {
            // In a full implementation, we would verify that the expression is a numeric type
        }
        
        return null;
    }
    
    /**
     * Visit a primary expression (literals, variables, function calls, etc.)
     */
    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        // Handle different types of primary expressions
        if (ctx.INT_VALUE() != null) {
            // Integer literal
            return "INT";
        } else if (ctx.STRING_VALUE() != null) {
            // String literal
            return "STRING";
        } else if (ctx.CHAR_VALUE() != null) {
            // Character literal
            return "CHAR";
        } else if (ctx.TRUE() != null || ctx.FALSE() != null) {
            // Boolean literal
            return "BOOL";
        } else if (ctx.NOT() != null) {
            // NOT expression
            visit(ctx.primaryExpression());
            return "BOOL";
        } else if (ctx.tupleValue() != null) {
            // Tuple value
            visit(ctx.tupleValue());
            return "TUPLE";
        } else if (ctx.EMOJI_ID() != null) {
            // Variable reference
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);
            if (info == null) {
                errorLogger.addError(new EMJError("varIdNotDecl", 
                    "Variable " + varId + " not declared", ctx.start.getLine()));
                return "UNKNOWN";
            }
            return info.getDataType();
        } else if (ctx.functionCall() != null) {
            // Function call
            visit(ctx.functionCall());
            // In a full implementation, we would return the function's return type
            return "UNKNOWN";
        } else if (ctx.leftExpression() != null) {
            // Left expression
            visit(ctx.leftExpression());
            // In a full implementation, we would return the variable's type
            return "UNKNOWN";
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return visit(ctx.expression());
        }
        
        return "UNKNOWN";
    }
    
    /**
     * Visit a tuple value
     */
    @Override
    public Object visitTupleValue(EMJParser.TupleValueContext ctx) {
        // Visit both expressions in the tuple
        visit(ctx.expression(0));
        visit(ctx.expression(1));
        
        return "TUPLE";
    }
    
    /**
     * Visit predefined statements (built-in robot actions)
     */
    @Override
    public Object visitPredefinedStmt(EMJParser.PredefinedStmtContext ctx) {
        System.out.println("Visiting predefined statement...");
        
        // In a full implementation, we would verify parameters for move commands
        if (ctx.INT_VALUE() != null) {
            // This is a move command with a distance parameter
        }
        
        return null;
    }


    /**
     * Visit a map file
     */
    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }



//
//
//    SEMANTIC_VAR_AFFECT
//    */
//    @Override
//    public Object visitVarAffect(EMJParser.VarAffectContext ctx) {
//
//        // SEMANTIC_CHECK_VAR_IS_DECL : Check if an id in a variable affectation has been previously declared
//        String varId = ctx.EMOJI_ID().getText();
//
//        // If the variable id is not contained in the variable id array, add an error
//        if(!this.varIds.contains(varId)) {
//            this.errorLogger.addError(new EMJError("varIdNotDecl", ctx.getText(), ctx.start.getLine()));
//        }
//
//        return null;
//    }
}