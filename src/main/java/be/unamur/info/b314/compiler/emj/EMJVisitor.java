package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJParser;

import java.util.ArrayList;
import java.util.List;

/*
Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
@author : Alix Decrop
@version : 1.0
*/
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private final EMJErrorLogger errorLogger;
    private final EMJSymbolTable symbolTable;

    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
    }


    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }

    /*
    SEMANTIC_VAR_DECL
    */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx){
        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            visitFunctionDecl(functionDeclContext);
        }
        visit(ctx.mainFunction());
        return null;
    }
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", ctx.getText(), ctx.start.getLine()));
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        this.symbolTable.addVariable(varId, varType, isInitialized);
        // Need to check type compatibility
        if (isInitialized) {
            // Visit the expression to determine its type
            String exprType = getExpressionType(ctx.expression());

            if (!areTypesCompatible(varType, exprType)) {
                this.errorLogger.addError(new EMJError(
                        "typeMismatch",
                        "Cannot initialize variable of type '" + varType +
                                "' with an expression of type '" + exprType + "'",
                        ctx.start.getLine()
                ));
            }
        }

        return null;
    }

    private boolean areTypesCompatible(String declaredType, String exprType) {
        if (declaredType == null || exprType == null || "UNKNOWN".equals(declaredType) || "UNKNOWN".equals(exprType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (declaredType.equals(exprType)) {
            return true;
        }

        // Si l'un est un tuple et l'autre ne l'est pas, ils sont incompatibles
        if (declaredType.startsWith("TUPLE(") && !exprType.startsWith("TUPLE(")) {
            return false;
        }

        if (!declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            return false;
        }

        // Pour deux tuples, v√©rifier la compatibilit√© des types internes
        if (declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            String declaredInner = declaredType.substring(6, declaredType.length() - 1).trim();
            String exprInner = exprType.substring(6, exprType.length() - 1).trim();
            return areTypesCompatible(declaredInner, exprInner);
        }

        return false;
    }



    /**
     * V√©rifie si les types sont compatibles pour une op√©ration de comparaison
     * @param leftType Le type de l'expression gauche
     * @param rightType Le type de l'expression droite
     * @param ctx Le contexte de la comparaison
     * @return true si les types sont compatibles pour la comparaison, false sinon
     */
    private boolean areComparisonTypesCompatible(String leftType, String rightType, Object ctx) {
        // Si l'un des types est inconnu, consid√©rer comme incompatible
        if (leftType == null || rightType == null || "UNKNOWN".equals(leftType) || "UNKNOWN".equals(rightType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (leftType.equals(rightType)) {
            return true;
        }

        // Pour les op√©rateurs ==, != seuls les types identiques sont compatibles
        if (ctx instanceof EMJParser.ComparisonExpressionContext) {
            EMJParser.ComparisonExpressionContext compCtx = (EMJParser.ComparisonExpressionContext) ctx;
            if (compCtx.DOUBLE_EQUAL() != null || compCtx.NOTEQUAL() != null) {
                // Pour ces op√©rateurs, les types doivent √™tre identiques
                return false;
            }

            // Pour les op√©rateurs <, <=, >, >=, seuls les types num√©riques sont compatibles entre eux
            if (compCtx.LESS() != null || compCtx.LEQ() != null || compCtx.GREATER() != null || compCtx.GEQ() != null) {
                // Pour ces op√©rateurs, les deux op√©randes doivent √™tre des nombres
                return "INT".equals(leftType) && "INT".equals(rightType);
            }
        }

        // Par d√©faut, les types sont consid√©r√©s comme incompatibles
        return false;
    }

    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        } else if (typeCtx.tupleType() != null) {
            EMJParser.TupleTypeContext tupleCtx = typeCtx.tupleType();
            String innerType = getTypeFromContext(tupleCtx.type());
            return "TUPLE(" + innerType + ")";
        }
        return "UNKNOWN";
    }



    private String getExpressionType(EMJParser.ExpressionContext ctx) {
        // Visiter l'expression et r√©cup√©rer le r√©sultat
        Object result = visit(ctx);

        // Convertir le r√©sultat en type
        if (result instanceof String) {
            return (String) result;
        }

        return "UNKNOWN";
    }

    // Override des m√©thodes de visite pour chaque type d'expression
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // D√©l√©guer √† la m√©thode de visite pour orExpression
        return visit(ctx.orExpression());
    }

    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // S'il y a plus d'une andExpression connect√©e par OR, c'est un bool√©en
        if (!ctx.OR().isEmpty()) {
            return "BOOL";
        }

        // Sinon, d√©l√©guer au premier andExpression
        return visit(ctx.andExpression(0));
    }

    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // S'il y a plus d'une notExpression connect√©e par AND, c'est un bool√©en
        if (!ctx.AND().isEmpty()) {
            return "BOOL";
        }

        // Sinon, d√©l√©guer au premier notExpression
        return visit(ctx.notExpression(0));
    }

    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // S'il y a un NOT, c'est un bool√©en
        if (ctx.NOT() != null) {
            return "BOOL";
        }

        // Sinon, d√©l√©guer √† comparisonExpression
        return visit(ctx.comparisonExpression());
    }

    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // S'il y a un op√©rateur de comparaison, c'est un bool√©en
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null ||
                ctx.LESS() != null || ctx.LEQ() != null ||
                ctx.GREATER() != null || ctx.GEQ() != null) {
            // R√©cup√©rer les types des op√©randes de la comparaison
            String leftType = (String) visit(ctx.additiveExpression(0));
            String rightType = (String) visit(ctx.additiveExpression(1));

            // V√©rifier la compatibilit√© des types pour l'op√©ration de comparaison
            if (!areComparisonTypesCompatible(leftType, rightType, ctx)) {
                // Ajouter une erreur s√©mantique si les types sont incompatibles
                errorLogger.addError(new EMJError(
                    "incompatibleComparisonTypes",
                    "Cannot compare values of incompatible types: '" + leftType + "' and '" + rightType + "'",
                    ctx.start.getLine()
                ));
            }

            return "BOOL";
        }

        // Cas sans op√©rateur de comparaison, on envoie √† la sous-expression unique
        return visit(ctx.additiveExpression(0));
    }



    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // On commence par le premier op√©rande
        Object leftObj = visit(ctx.multiplicativeExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";

        if (ctx.multiplicativeExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            Object rightObj = visit(ctx.multiplicativeExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // V√©rifie que les deux op√©randes sont des entiers
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '+' or '-' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // Pour les it√©rations suivantes - ne pas forcer le type si erreur
            if (!hasTypeError) {
                leftType = "INT";
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }


    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        Object leftObj = visit(ctx.unaryExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";
        if (ctx.unaryExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;
        
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            Object rightObj = visit(ctx.unaryExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // V√©rifie que les types sont bien INT
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '*' or '/' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // V√©rifie la division par z√©ro uniquement si la valeur est litt√©rale
            if (ctx.DIVIDE(i - 1) != null) { // V√©rifie si c'est un op√©rateur '/'
                EMJParser.UnaryExpressionContext rightExpr = ctx.unaryExpression(i);
                if (rightExpr.primaryExpression() != null && rightExpr.primaryExpression().INT_VALUE() != null) {
                    String valueText = rightExpr.primaryExpression().INT_VALUE().getText();
                    try {
                        int val = Integer.parseInt(valueText);
                        if (val == 0) {
                            errorLogger.addError(new EMJError(
                                    "divisionByZero",
                                    "Division by zero is not allowed.",
                                    ctx.start.getLine()
                            ));
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            }

            // Ne pas forcer le type √† INT si une erreur a √©t√© d√©tect√©e
            if (!hasTypeError) {
                leftType = "INT"; 
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }

    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // S'il y a un - unaire, c'est un entier
        if (ctx.MINUS() != null) {
            return "INT";
        }

        // Sinon, d√©l√©guer √† primaryExpression
        return visit(ctx.primaryExpression());
    }

    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        // D√©terminer le type en fonction du contenu
        if (ctx.INT_VALUE() != null) {
            String intValue = ctx.INT_VALUE().getText();

            // V√©rifier si l'entier commence par 0 (sauf s'il est √©gal √† 0)
            if (intValue.length() > 1 && intValue.charAt(0) == '0') {
                errorLogger.addError(new EMJError(
                        "intStartsWithZero",
                        "Integer value cannot start with 0: " + intValue,
                        ctx.start.getLine()
                ));
            }

            // V√©rifier si l'entier est trop grand ou trop petit
            try {
                int value = Integer.parseInt(intValue);
                // En Java, Integer.MAX_VALUE est 2^31-1 et Integer.MIN_VALUE est -2^31
                // Mais nous pouvons d√©finir nos propres limites pour le langage EMJ
                if (value > 1000000000) { // 10^9 comme limite sup√©rieure
                    errorLogger.addError(new EMJError(
                            "integerTooBig",
                            "Integer value too big: " + intValue,
                            ctx.start.getLine()
                    ));
                } else if (value < -1000000000) { // -10^9 comme limite inf√©rieure
                    errorLogger.addError(new EMJError(
                            "integerTooSmall",
                            "Integer value too small: " + intValue,
                            ctx.start.getLine()
                    ));
                }
            } catch (NumberFormatException e) {
                // Si l'entier ne peut pas √™tre pars√© (trop grand pour un int Java)
                errorLogger.addError(new EMJError(
                        "invalidIntegerFormat",
                        "Invalid integer format: " + intValue,
                        ctx.start.getLine()
                ));
            }

            return "INT";
        } else if (ctx.STRING_VALUE() != null) {
            return "STRING";
        } else if (ctx.CHAR_VALUE() != null) {
            return "CHAR";
        } else if (ctx.TRUE() != null || ctx.FALSE() != null) {
            return "BOOL";
        } else if (ctx.tupleValue() != null) {
            // Pour les tuples, il faut obtenir le type des √©l√©ments
            String elementType1 = (String) visit(ctx.tupleValue().expression(0));
            String elementType2 = (String) visit(ctx.tupleValue().expression(1));

            // V√©rifier que les deux √©l√©ments ont le m√™me type
            if (!elementType1.equals(elementType2)) {
                errorLogger.addError(new EMJError(
                        "tupleMismatchedTypes",
                        "Tuple elements must have the same type, found: " + elementType1 + " and " + elementType2,
                        ctx.start.getLine()
                ));
            }

            return "TUPLE(" + elementType1 + ")";
        } else if (ctx.EMOJI_ID() != null) {
            // Pour les variables, consulter la table des symboles
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            // D√©tecter les cas comme "üòç1Ô∏è" o√π il y a un emoji suivi d'un chiffre
            // Ce n'est pas un moyen valide d'acc√©der aux √©l√©ments de tuple
            if (ctx.getChildCount() > 1 && ctx.getChild(1) != null) {
                String nextToken = ctx.getChild(1).getText();
                if (nextToken.matches(".*\\d.*")) {  // D√©tecte si le token contient un chiffre
                    errorLogger.addError(new EMJError(
                            "invalidTupleAccess",
                            "Invalid tuple access syntax: " + ctx.getText(),
                            ctx.start.getLine()
                    ));
                    return "UNKNOWN";
                }
            }

            return info != null ? info.getType() : "UNKNOWN";
        } else if (ctx.functionCall() != null) {
            // Pour les appels de fonction, consulter la table des symboles
            return visitFunctionCall(ctx.functionCall());
        } else if (ctx.leftExpression() != null) {
            // Pour les expressions gauches, utiliser une m√©thode auxiliaire
            return getLeftExpressionType(ctx.leftExpression());
        } else if (ctx.expression() != null) {
            // Pour les expressions entre parenth√®ses, visiter r√©cursivement
            return visit(ctx.expression());
        } else if (ctx.NOT() != null && ctx.primaryExpression() != null) {
            // Pour les expressions n√©g√©es avec NOT
            String exprType = (String) visit(ctx.primaryExpression());
            if (!"BOOL".equals(exprType)) {
                errorLogger.addError(new EMJError(
                        "invalidNegationOperand",
                        "Operand of NOT must be of type BOOL, found: " + exprType,
                        ctx.start.getLine()
                ));
                return "UNKNOWN";
            }
            return "BOOL";
        }

        return "UNKNOWN";
    }


    // M√©thode auxiliaire pour obtenir le type d'une expression gauche
//    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
//        String varId = ctx.EMOJI_ID().getText();
//        EMJSymbolInfo info = symbolTable.lookup(varId);
//
//        if (info == null) {
//            return "UNKNOWN";
//        }
//
//        // Si on tente d‚Äôacc√©der √† un √©l√©ment tuple, mais que la variable n‚Äôest pas un tuple
//        if ((ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null)) {
//            String type = info.getType();
//            if (!type.startsWith("TUPLE(")) {
//                errorLogger.addError(new EMJError(
//                        "invalidTupleAccess",
//                        "Trying to access an element of non-tuple variable '" + varId + "'",
//                        ctx.getStart().getLine()
//                ));
//                return "UNKNOWN";
//            }
//
//            // Retourner le type interne du tuple
//            return type.substring(6, type.length() - 1);
//        }
//
//        return info.getType();
//    }


    // M√©thode auxiliaire pour obtenir le type d'une expression gauche
    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        EMJSymbolInfo info = symbolTable.lookup(varId);

        if (info == null) {
            errorLogger.addError(new EMJError(
                    "undeclaredVariable",
                    "Variable '" + varId + "' is not declared",
                    ctx.getStart().getLine()
            ));
            return "UNKNOWN";
        }

        String varType = info.getType();

        // Si on acc√®de √† un √©l√©ment d'un tuple
        if (ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null) {
            if (!varType.startsWith("TUPLE(")) {
                errorLogger.addError(new EMJError(
                        "invalidTupleAccess",
                        "Cannot access tuple element from non-tuple variable '" + varId + "'",
                        ctx.getStart().getLine()
                ));
                return "UNKNOWN";
            }

            // Extraire le type interne du tuple (ce qui est entre parenth√®ses)
            return varType.substring(6, varType.length() - 1);
        }

        return varType;
    }



    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }


    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {

        symbolTable.enterScope("main");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        // R√©cup√©rer l'identifiant de la fonction
        String funcId = ctx.EMOJI_ID().getText();

        // R√©cup√©rer le type de retour
        String returnType = getTypeFromContext(ctx.returnType());

        // R√©cup√©rer les param√®tres
        List<EMJParameterInfo> parameters = new ArrayList<>();
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            EMJParser.ParamListContext paramListCtx = ctx.optionalParamList().paramList();
            for (EMJParser.ParamContext paramCtx : paramListCtx.param()) {
                String paramId = paramCtx.EMOJI_ID().getText();
                String paramType = getTypeFromContext(paramCtx.type());
                parameters.add(new EMJParameterInfo(paramId, paramType));
            }
        }

        // V√©rifier si la fonction existe d√©j√†
        if (symbolTable.functionExists(funcId)) {
            errorLogger.addError(new EMJError("functionAlreadyDefined",
                    "Function " + funcId + " is already defined", ctx.start.getLine()));
            return null;
        }

        // Ajouter la fonction √† la table des symboles
        symbolTable.addFunction(funcId, returnType, parameters);

        // Entrer dans la port√©e de la fonction
        symbolTable.enterScope("function_" + funcId);

        // Ajouter les param√®tres dans la port√©e de la fonction
        for (EMJParameterInfo param : parameters) {
            symbolTable.addVariable(param.getId(), param.getType(), true);
        }

        // Visiter le corps de la fonction
        Object result = visitChildren(ctx);

        // Sortir de la port√©e de la fonction
        symbolTable.exitScope();

        return result;
    }

    // M√©thode auxiliaire pour obtenir le type √† partir d'un contexte de type
    private String getTypeFromContext(EMJParser.ReturnTypeContext ctx) {
        if (ctx.VOID_TYPE() != null) {
            return "VOID";
        } else if (ctx.type() != null) {
            return getTypeFromContext(ctx.type());
        }
        return "UNKNOWN";
    }


    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {

        symbolTable.enterScope("loop");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {

        symbolTable.enterScope("if");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {

        symbolTable.enterScope("block");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }


    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        // SEMANTIC_CHECK_VAR_IS_DECL : Check if an id in a variable affectation has been previously declared
        String varId = ctx.leftExpression().EMOJI_ID().getText();

        // If the variable id is not contained in the variable id array, add an error
        EMJSymbolInfo leftVar = this.symbolTable.lookup(varId);
        if (leftVar == null) {
            this.errorLogger.addError(new EMJError("varIdNotDecl", ctx.getText(), ctx.start.getLine()));
            return null;
        }

        // Analyser l'expression de droite
        EMJParser.ExpressionContext exprCtx = ctx.expression();

        // V√©rifier pour le cas sp√©cifique o√π on essaie d'acc√©der √† un √©l√©ment de tuple de mani√®re incorrecte
        if (exprCtx.getText().matches(".*[üòç]\\d+.*")) {
            this.errorLogger.addError(new EMJError(
                    "invalidTupleAccess",
                    "Invalid tuple access syntax in assignment: " + exprCtx.getText(),
                    ctx.start.getLine()
            ));
            return null;
        }

        String exprType = getExpressionType(exprCtx);

        // V√©rifier la compatibilit√© des types
        if (!areTypesCompatible(leftVar.getType(), exprType)) {
            this.errorLogger.addError(new EMJError(
                    "typeMismatch",
                    "Cannot assign variable of type '" + leftVar.getType() +
                            "' with an expression of type '" + exprType + "'",
                    ctx.start.getLine()
            ));
        }

        return null;
    }

    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String functionName = ctx.EMOJI_ID().getText(); // Retrieve the name of the called function

        // Retrieve the number of arguments passed to the function call
        List<EMJParser.ExpressionContext> args =
                ctx.argumentList() != null ? ctx.argumentList().expression() : new ArrayList<>();

        // Retrieve the function definition from the symbol table
        EMJSymbolInfo functionSymbol = symbolTable.lookup(functionName);

        if (functionSymbol == null || functionSymbol.getSymbolType() != EMJSymbolType.FUNCTION) {
            errorLogger.addError(new EMJError("Function not declared", functionName, ctx.getStart().getLine()));
            return "UNKNOWN";
        }

        // V√©rifier si la fonction est de type void et si elle est appel√©e dans une expression
        if ("VOID".equals(functionSymbol.getReturnType())) {
            // Pour les fonctions void, v√©rifier si elles sont utilis√©es dans une expression
            // Nous consid√©rons tout contexte autre qu'une instruction directe comme une expression
            boolean isUsedInExpression = true; // Par d√©faut, consid√©rer comme utilis√© dans une expression
            
            // V√©rifier si l'appel est directement dans une instruction (statement)
            if (ctx.getParent() instanceof EMJParser.FunctionCallStmtContext) {
                isUsedInExpression = false;
            }

            if (isUsedInExpression) {
                // Ajouter une erreur s√©mantique pour l'utilisation d'une fonction void dans une expression
                errorLogger.addError(new EMJError(
                    "voidFunctionInExpression",
                    "Function " + functionName + " has void return type and cannot be used in an expression",
                    ctx.getStart().getLine()
                ));
            }
        }

        int expected = functionSymbol.getParameters() != null ? functionSymbol.getParameters().size() : 0;
        int actual = args.size();

        if (actual < expected) {
            errorLogger.addError(new EMJError("Too few parameters", functionName, ctx.getStart().getLine()));
        } else if (actual > expected) {
            errorLogger.addError(new EMJError("Too many parameters", functionName, ctx.getStart().getLine()));
        }

        // Visit each argument expression to perform semantic checks
        for (int i = 0; i < Math.min(actual, expected); i++) {
            String argType = (String) visit(args.get(i));
            if (functionSymbol.getParameters() != null && i < functionSymbol.getParameters().size()) {
                String paramType = functionSymbol.getParameters().get(i).getType();
                if (!areTypesCompatible(paramType, argType)) {
                    errorLogger.addError(new EMJError(
                        "paramTypeMismatch",
                        "Parameter " + (i+1) + " of function " + functionName + " expects type " + 
                        paramType + " but got " + argType,
                        ctx.getStart().getLine()
                    ));
                }
            }
        }

        // Return the function's return type
        return functionSymbol.getReturnType();
    }
}