package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJLexer;
import be.unamur.info.b314.compiler.EMJParser;
import be.unamur.info.b314.compiler.emj.EMJError;
import be.unamur.info.b314.compiler.emj.EMJErrorLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/*
Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
@author : Alix Decrop
@version : 1.0
*/
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private EMJErrorLogger errorLogger;
    private EMJSymbolTable symbolTable;

    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
    }


    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }

    /*
    SEMANTIC_VAR_DECL
    */
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", ctx.getText(), ctx.start.getLine()));
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        this.symbolTable.addVariable(varId, varType, isInitialized);
        // Need to check type compatibility
        if (isInitialized) {
            // Visit the expression to determine its type
            String exprType = getExpressionType(ctx.expression());

            if (!areTypesCompatible(varType, exprType)) {
                this.errorLogger.addError(new EMJError(
                        "typeMismatch",
                        "Cannot initialize variable of type '" + varType +
                                "' with an expression of type '" + exprType + "'",
                        ctx.start.getLine()
                ));
            }
        }

        return null;
    }

    private boolean areTypesCompatible(String declaredType, String exprType) {
        // Direct match
        if (declaredType.equals(exprType)) {
            return true;
        }

        // Tuple compatibility
        if (declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            String innerDeclaredType = declaredType.substring(6, declaredType.length() - 1);
            String innerExprType = exprType.substring(6, exprType.length() - 1);
            return areTypesCompatible(innerDeclaredType, innerExprType);
        }

        return false;
    }

    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        }else if (typeCtx.tupleType() != null) {
            // It's a tuple - get the inner type
            EMJParser.TupleTypeContext tupleCtx = typeCtx.tupleType();
            String innerType = getTypeFromContext(tupleCtx.type());
            return "TUPLE(" + innerType + ")";
        }

        return "UNKNOWN";
    }

    private String getExpressionType(EMJParser.ExpressionContext ctx) {
        // Visiter l'expression et récupérer le résultat
        Object result = visit(ctx);

        // Convertir le résultat en type
        if (result instanceof String) {
            return (String) result;
        }

        return "UNKNOWN";
    }

    // Override des méthodes de visite pour chaque type d'expression
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Déléguer à la méthode de visite pour orExpression
        return visit(ctx.orExpression());
    }

    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // S'il y a plus d'une andExpression connectée par OR, c'est un booléen
        if (ctx.OR().size() > 0) {
            return "BOOL";
        }

        // Sinon, déléguer au premier andExpression
        return visit(ctx.andExpression(0));
    }

    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // S'il y a plus d'une notExpression connectée par AND, c'est un booléen
        if (ctx.AND().size() > 0) {
            return "BOOL";
        }

        // Sinon, déléguer au premier notExpression
        return visit(ctx.notExpression(0));
    }

    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // S'il y a un NOT, c'est un booléen
        if (ctx.NOT() != null) {
            return "BOOL";
        }

        // Sinon, déléguer à comparisonExpression
        return visit(ctx.comparisonExpression());
    }

    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // S'il y a un opérateur de comparaison, c'est un booléen
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null ||
                ctx.LESS() != null || ctx.LEQ() != null ||
                ctx.GREATER() != null || ctx.GEQ() != null) {
            return "BOOL";
        }

        // Sinon, déléguer au premier additiveExpression
        return visit(ctx.additiveExpression(0));
    }

    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // On commence par le premier opérande
        Object leftObj = visit(ctx.multiplicativeExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            Object rightObj = visit(ctx.multiplicativeExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Vérifie que les deux opérandes sont des entiers
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '+' or '-' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
            }

            // Pour les itérations suivantes
            leftType = "INT";
        }

        return "INT";
    }


    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        Object leftObj = visit(ctx.unaryExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";

        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            Object rightObj = visit(ctx.unaryExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Vérifie que les types sont bien INT
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '*' or '/' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
            }

            // Vérifie la division par zéro uniquement si la valeur est littérale
            if (ctx.DIVIDE(i - 1) != null) { // Vérifie si c’est un opérateur '/'
                EMJParser.UnaryExpressionContext rightExpr = ctx.unaryExpression(i);
                if (rightExpr.primaryExpression() != null && rightExpr.primaryExpression().INT_VALUE() != null) {
                    String valueText = rightExpr.primaryExpression().INT_VALUE().getText();
                    try {
                        int val = Integer.parseInt(valueText);
                        if (val == 0) {
                            errorLogger.addError(new EMJError(
                                    "divisionByZero",
                                    "Division by zero is not allowed.",
                                    ctx.start.getLine()
                            ));
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            }

            leftType = "INT"; // continuer avec un type INT
        }

        return "INT";
    }

    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // S'il y a un - unaire, c'est un entier
        if (ctx.MINUS() != null) {
            return "INT";
        }

        // Sinon, déléguer à primaryExpression
        return visit(ctx.primaryExpression());
    }

    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        // Déterminer le type en fonction du contenu
        if (ctx.INT_VALUE() != null) {
            return "INT";
        } else if (ctx.STRING_VALUE() != null) {
            return "STRING";
        } else if (ctx.CHAR_VALUE() != null) {
            return "CHAR";
        } else if (ctx.TRUE() != null || ctx.FALSE() != null) {
            return "BOOL";
        } else if (ctx.tupleValue() != null) {
            // Pour les tuples, il faut obtenir le type des éléments
            String elementType = (String) visit(ctx.tupleValue().expression(0));
            return "TUPLE(" + elementType + ")";
        } else if (ctx.EMOJI_ID() != null) {
            // Pour les variables, consulter la table des symboles
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);
            return info != null ? info.getType() : "UNKNOWN";
        } else if (ctx.functionCall() != null) {
            // Pour les appels de fonction, consulter la table des symboles
            String funcId = ctx.functionCall().EMOJI_ID().getText();
            EMJSymbolInfo funcInfo = symbolTable.lookup(funcId);
            return funcInfo != null ? funcInfo.getReturnType() : "UNKNOWN";
        } else if (ctx.leftExpression() != null) {
            // Pour les expressions gauches, utiliser une méthode auxiliaire
            return getLeftExpressionType(ctx.leftExpression());
        } else if (ctx.expression() != null) {
            // Pour les expressions entre parenthèses, visiter récursivement
            return visit(ctx.expression());
        }

        return "UNKNOWN";
    }

    // Méthode auxiliaire pour obtenir le type d'une expression gauche
    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        EMJSymbolInfo info = symbolTable.lookup(varId);

        if (info == null) {
            return "UNKNOWN";
        }

        // Vérifier s'il s'agit d'un accès à un élément de tuple
        if (ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null) {
            String type = info.getType();
            if (type.startsWith("TUPLE(") && type.endsWith(")")) {
                return type.substring(6, type.length() - 1);
            }
            return "UNKNOWN"; // Pas un tuple
        }

        return info.getType();
    }
    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }


    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {

        symbolTable.enterScope("main");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        // Récupérer l'identifiant de la fonction
        String funcId = ctx.EMOJI_ID().getText();

        // Récupérer le type de retour
        String returnType = getTypeFromContext(ctx.returnType());

        // Récupérer les paramètres
        List<EMJParameterInfo> parameters = new ArrayList<>();
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            EMJParser.ParamListContext paramListCtx = ctx.optionalParamList().paramList();
            for (EMJParser.ParamContext paramCtx : paramListCtx.param()) {
                String paramId = paramCtx.EMOJI_ID().getText();
                String paramType = getTypeFromContext(paramCtx.type());
                parameters.add(new EMJParameterInfo(paramId, paramType));
            }
        }

        // Vérifier si la fonction existe déjà
        if (symbolTable.functionExists(funcId)) {
            errorLogger.addError(new EMJError("functionAlreadyDefined",
                    "Function " + funcId + " is already defined", ctx.start.getLine()));
            return null;
        }

        // Ajouter la fonction à la table des symboles
        symbolTable.addFunction(funcId, returnType, parameters);

        // Entrer dans la portée de la fonction
        symbolTable.enterScope("function_" + funcId);

        // Ajouter les paramètres dans la portée de la fonction
        for (EMJParameterInfo param : parameters) {
            symbolTable.addVariable(param.getId(), param.getType(), true);
        }

        // Visiter le corps de la fonction
        Object result = visitChildren(ctx);

        // Sortir de la portée de la fonction
        symbolTable.exitScope();

        return result;
    }

    // Méthode auxiliaire pour obtenir le type à partir d'un contexte de type
    private String getTypeFromContext(EMJParser.ReturnTypeContext ctx) {
        if (ctx.VOID_TYPE() != null) {
            return "VOID";
        } else if (ctx.type() != null) {
            return getTypeFromContext(ctx.type());
        }
        return "UNKNOWN";
    }


    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {

        symbolTable.enterScope("loop");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {

        symbolTable.enterScope("if");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {

        symbolTable.enterScope("block");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }


    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx){

        // SEMANTIC_CHECK_VAR_IS_DECL : Check if an id in a variable affectation has been previously declared
        String varId = ctx.leftExpression().EMOJI_ID().getText();

        // If the variable id is not contained in the variable id array, add an error
        EMJSymbolInfo var = this.symbolTable.lookup(varId);
        if(var == null) {
            this.errorLogger.addError(new EMJError("varIdNotDecl", ctx.getText(), ctx.start.getLine()));
        }

        String exprType = getExpressionType(ctx.expression());

        if (!areTypesCompatible(var.getType(), exprType)) {
            this.errorLogger.addError(new EMJError(
                    "typeMismatch",
                    "Cannot initialize variable of type '" + var.getType() +
                            "' with an expression of type '" + exprType + "'",
                    ctx.start.getLine()
            ));
        }
        return null;
    }
}