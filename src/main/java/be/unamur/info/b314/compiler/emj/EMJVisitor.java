package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJLexer;
import be.unamur.info.b314.compiler.EMJParser;
import be.unamur.info.b314.compiler.EMJParserBaseVisitor;
import be.unamur.info.b314.compiler.emj.EMJError;
import be.unamur.info.b314.compiler.emj.EMJErrorLogger;
import be.unamur.info.b314.compiler.emj.EMJSymbolTable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
 * Implements the visitor pattern to traverse AST and perform semantic analysis
 * 
 * @author : Alix Decrop
 * @version : 1.0
 */
public class EMJVisitor extends EMJParserBaseVisitor<Object> {

    private EMJErrorLogger errorLogger;
    private EMJSymbolTable symbolTable;
    private String currentScope; // Keeps track of the current function scope

    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
        this.currentScope = "global";
    }

    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }
    
    /**
     * Visit the root node of the AST
     * Entry point for the visitor pattern
     */
    @Override
    public Object visitRoot(EMJParser.RootContext ctx) {
        System.out.println("Visiting program root...");
        
        // Visit child nodes (either mapFile or programFile)
        return visitChildren(ctx);
    }
    
    /**
     * Visit the program file node which contains the main structure of an EMJ program
     */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx) {
        System.out.println("Visiting program file...");
        
        // Process the import statement if it exists
        if (ctx.importStatement() != null) {
            visit(ctx.importStatement());
        }
        
        // Visit main function (required)
        visit(ctx.mainFunction());
        
        // Visit all function declarations
        for (EMJParser.FunctionDeclContext funcCtx : ctx.functionDecl()) {
            visit(funcCtx);
        }
        
        // Visit any statements at global scope
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        return null;
    }
    
    /**
     * Visit import statement that imports a map file
     */
    @Override
    public Object visitImportStatement(EMJParser.ImportStatementContext ctx) {
        System.out.println("Visiting import statement: " + ctx.STRING_VALUE().getText());
        // Process the map file import - in a full implementation, this would verify the map file exists
        return null;
    }
    
    /**
     * Visit the main function declaration
     */
    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {
        System.out.println("Visiting main function...");
        
        // Set current scope to main for symbol table tracking
        String previousScope = this.currentScope;
        this.currentScope = "main";
        
        // Create a new scope in the symbol table for the main function
        this.symbolTable.enterScope("main");
        
        // Visit all statements in the main function body
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        // Exit the scope when done with main function
        this.symbolTable.exitScope();
        this.currentScope = previousScope;
        
        return null;
    }
    
    /**
     * Visit a function declaration
     */
    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        String funcId = ctx.EMOJI_ID().getText();
        System.out.println("Visiting function declaration: " + funcId);
        
        // SEMANTIC_CHECK_FUNC_ID_ALREADY_EXISTS : Check if the function id already exists in the current scope
        if (this.symbolTable.lookup(funcId) != null) {
            this.errorLogger.addError(new EMJError("funcIdAlreadyExists", 
                "Function " + funcId + " already exists", ctx.start.getLine()));
        }
        
        // Get the return type of the function
        String returnType = "VOID";
        if (ctx.returnType().type() != null) {
            returnType = getTypeFromContext(ctx.returnType().type());
        }
        
        // Add function to symbol table
        this.symbolTable.addFunction(funcId, returnType);
        
        // Create a new scope for the function
        this.symbolTable.enterScope(funcId);
        
        // Process parameters if they exist
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            visit(ctx.optionalParamList());
        }
        
        // Visit all statements in the function body
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        // Visit the return statement if it exists
        if (ctx.returnStatement() != null) {
            visit(ctx.returnStatement());
            // TODO: Verify that return type matches declared type
        } else {
            // If no return statement, function must be void
            if (!returnType.equals("VOID")) {
                this.errorLogger.addError(new EMJError("missingReturnStatement", 
                    "Non-void function " + funcId + " missing return statement", ctx.start.getLine()));
            }
        }
        
        // Exit the function scope
        this.symbolTable.exitScope();
        
        return null;
    }
    
    /**
     * Visit parameter list in function declaration
     */
    @Override
    public Object visitOptionalParamList(EMJParser.OptionalParamListContext ctx) {
        // If no parameters, nothing to do
        if (ctx.paramList() == null) {
            return null;
        }
        
        // Visit the parameter list
        return visit(ctx.paramList());
    }
    
    /**
     * Visit parameter list and process each parameter
     */
    @Override
    public Object visitParamList(EMJParser.ParamListContext ctx) {
        // Visit each parameter in the list
        for (EMJParser.ParamContext paramCtx : ctx.param()) {
            visit(paramCtx);
        }
        
        return null;
    }
    
    /**
     * Visit a single parameter in a function declaration
     */
    @Override
    public Object visitParam(EMJParser.ParamContext ctx) {
        String paramId = ctx.EMOJI_ID().getText();
        String paramType = getTypeFromContext(ctx.type());
        
        // Add parameter to symbol table for current function scope
        // Parameters are initialized by definition
        this.symbolTable.addVariable(paramId, paramType, true);
        
        return null;
    }
    
    /**
     * Visit a statement node in the AST
     */
    @Override
    public Object visitStatement(EMJParser.StatementContext ctx) {
        System.out.println("Visiting statement...");
        
        // Delegate to the appropriate visit method based on the type of statement
        return visitChildren(ctx);
    }
    
    /**
     * Visit a return statement
     */
    @Override
    public Object visitReturnStatement(EMJParser.ReturnStatementContext ctx) {
        System.out.println("Visiting return statement...");
        
        // Handle different return statement types
        if (ctx.expression() != null) {
            // Return with expression - check type compatibility with function return type
            visit(ctx.expression());
            
            // In a full implementation, we would verify that the expression type
            // matches the function's declared return type
        }
        
        return null;
    }
    
    /**
     * Visit an if statement
     */
    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {
        System.out.println("Visiting if statement...");
        
        // Visit the condition expression
        visit(ctx.expression());
        
        // In a full implementation, we would verify that the condition is a boolean expression
        
        // Visit the true branch (required)
        visit(ctx.block(0));
        
        // Visit the else branch if it exists
        if (ctx.block().size() > 1) {
            visit(ctx.block(1));
        }
        
        return null;
    }
    
    /**
     * Visit a loop statement (while or for)
     */
    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {
        System.out.println("Visiting loop statement...");
        
        // Visit the condition expression
        visit(ctx.expression());
        
        // In a full implementation, we would verify that the condition is a boolean expression
        
        // Visit the loop body
        visit(ctx.block());
        
        return null;
    }
    
    /**
     * Visit a block of statements
     */
    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {
        // Visit each statement in the block
        for (EMJParser.StatementContext stmtCtx : ctx.statement()) {
            visit(stmtCtx);
        }
        
        return null;
    }

    /**
     * Visit a variable declaration statement
     * SEMANTIC_VAR_DECL
     */
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {
        System.out.println("Visiting variable declaration: " + ctx.EMOJI_ID().getText());

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", 
                "Variable " + varId + " already exists", ctx.start.getLine()));
            return null;
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        
        // If there's an initializing expression, visit it to validate it
        if (isInitialized) {
            visit(ctx.expression());
            // In a full implementation, we would verify type compatibility between
            // the declared variable type and the expression result type
        }
        
        this.symbolTable.addVariable(varId, varType, isInitialized);

        return null;
    }

    /**
     * Get the data type from a type context
     * 
     * @param typeCtx The type context from the parser
     * @return The string representation of the type
     */
    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        } else if (typeCtx.tupleType() != null) {
            return "TUPLE";
        }

        return "UNKNOWN";
    }
    
    /**
     * Visit assignment statement
     */
    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        System.out.println("Visiting assignment...");
        
        // Visit the left expression (variable being assigned to)
        visit(ctx.leftExpression());
        
        // Visit the right expression (value being assigned)
        visit(ctx.expression());
        
        // In a full implementation, we would verify type compatibility
        // between the left expression and the right expression
        
        return null;
    }
    
    /**
     * Visit left expression (target of assignment)
     */
    @Override
    public Object visitLeftExpression(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        
        // Verify that the variable exists in the symbol table
        EMJSymbolInfo info = symbolTable.lookup(varId);
        if (info == null) {
            errorLogger.addError(new EMJError("varIdNotDecl", 
                "Variable " + varId + " not declared", ctx.start.getLine()));
        }
        
        // Check for tuple access
        boolean hasTupleAccess = ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null;
        if (hasTupleAccess && info != null) {
            // In a full implementation, we would verify that the variable is actually a tuple
            // and report an error if it's not
        }
        
        return null;
    }
    
    /**
     * Visit function call
     */
    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String funcId = ctx.EMOJI_ID().getText();
        System.out.println("Visiting function call: " + funcId);
        
        // Verify that the function exists in the symbol table
        EMJSymbolInfo info = symbolTable.lookup(funcId);
        if (info == null) {
            errorLogger.addError(new EMJError("funcIdNotDecl", 
                "Function " + funcId + " not declared", ctx.start.getLine()));
            return null;
        }
        
        // Visit arguments if they exist
        if (ctx.argumentList() != null) {
            visit(ctx.argumentList());
            
            // In a full implementation, we would verify argument count and types
        }
        
        return null;
    }
    
    /**
     * Visit argument list in a function call
     */
    @Override
    public Object visitArgumentList(EMJParser.ArgumentListContext ctx) {
        // Visit each argument expression
        for (EMJParser.ExpressionContext exprCtx : ctx.expression()) {
            visit(exprCtx);
        }
        
        return null;
    }
    
    /**
     * Visit an expression
     */
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Delegate to child expression (orExpression)
        return visitChildren(ctx);
    }
    
    /**
     * Visit an or expression (OR operator)
     * Returns the type of the expression (should be BOOL)
     */
    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // Visit the first and expression
        String firstType = (String) visit(ctx.andExpression(0));
        
        // If more than one expression, verify all are boolean
        for (int i = 1; i < ctx.andExpression().size(); i++) {
            String nextType = (String) visit(ctx.andExpression(i));
            
            // Check if both operands are boolean
            if (!firstType.equals("BOOL") || !nextType.equals("BOOL")) {
                this.errorLogger.addError(new EMJError("invalidBooleanOperand", 
                    "OR operator requires boolean operands, found " + firstType + " and " + nextType, 
                    ctx.start.getLine()));
            }
        }
        
        // OR expression always returns boolean
        return "BOOL";
    }
    
    /**
     * Visit an and expression (AND operator)
     * Returns the type of the expression (should be BOOL)
     */
    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // Visit the first not expression
        String firstType = (String) visit(ctx.notExpression(0));
        
        // If more than one expression, verify all are boolean
        for (int i = 1; i < ctx.notExpression().size(); i++) {
            String nextType = (String) visit(ctx.notExpression(i));
            
            // Check if both operands are boolean
            if (!firstType.equals("BOOL") || !nextType.equals("BOOL")) {
                this.errorLogger.addError(new EMJError("invalidBooleanOperand", 
                    "AND operator requires boolean operands, found " + firstType + " and " + nextType, 
                    ctx.start.getLine()));
            }
        }
        
        // AND expression always returns boolean
        return "BOOL";
    }
    
    /**
     * Visit a not expression (NOT operator)
     * Returns the type of the expression (should be BOOL if NOT is used)
     */
    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // Visit the comparison expression
        String exprType = (String) visit(ctx.comparisonExpression());
        
        // Check if NOT operator is present
        boolean hasNotOperator = ctx.NOT() != null;
        if (hasNotOperator) {
            // Verify that the expression is boolean type
            if (!exprType.equals("BOOL")) {
                this.errorLogger.addError(new EMJError("invalidBooleanOperand", 
                    "NOT operator requires boolean operand, found " + exprType, 
                    ctx.start.getLine()));
            }
            // NOT expression always returns boolean
            return "BOOL";
        }
        
        // If no NOT operator, just pass through the type
        return exprType;
    }
    
    /**
     * Visit a comparison expression (==, !=, <, <=, >, >=)
     * Returns the type of the expression (BOOL if comparison operator exists)
     */
    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // Visit the first additive expression
        String leftType = (String) visit(ctx.additiveExpression(0));
        
        // If there's a comparison operator, visit the second additive expression
        if (ctx.additiveExpression().size() > 1) {
            String rightType = (String) visit(ctx.additiveExpression(1));
            String operator = "";
            
            // Determine which comparison operator was used
            if (ctx.EQ() != null) operator = "==";
            else if (ctx.NEQ() != null) operator = "!=";
            else if (ctx.LT() != null) operator = "<";
            else if (ctx.LTE() != null) operator = "<=";
            else if (ctx.GT() != null) operator = ">";
            else if (ctx.GTE() != null) operator = ">=";
            
            // Check type compatibility for comparison
            // For equality and inequality, any types can be compared
            if (ctx.EQ() != null || ctx.NEQ() != null) {
                // Type comparison should be the same
                if (!leftType.equals(rightType)) {
                    this.errorLogger.addError(new EMJError("invalidComparisonOperand", 
                        "Equality comparison requires the same type for both operands, found " + 
                        leftType + " and " + rightType, ctx.start.getLine()));
                }
            } 
            // For <, <=, >, >=, operands must be numeric
            else if (ctx.LT() != null || ctx.LTE() != null || ctx.GT() != null || ctx.GTE() != null) {
                if (!leftType.equals("INT") || !rightType.equals("INT")) {
                    this.errorLogger.addError(new EMJError("invalidComparisonOperand", 
                        "Comparison operator " + operator + " requires integer operands, found " + 
                        leftType + " and " + rightType, ctx.start.getLine()));
                }
            }
            
            // Comparison expression always returns boolean
            return "BOOL";
        }
        
        // If no comparison operator, just pass through the type of the additive expression
        return leftType;
    }
    
    /**
     * Visit an additive expression (+, -)
     * Returns the type of the expression
     */
    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // Visit the first multiplicative expression
        String resultType = (String) visit(ctx.multiplicativeExpression(0));
        
        // Visit any additional multiplicative expressions (separated by + or -)
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            String nextType = (String) visit(ctx.multiplicativeExpression(i));
            String operator = ctx.ADD(i-1) != null ? "+" : "-";
            
            // Check type compatibility for addition/subtraction
            // Only integers can be added or subtracted
            if (!resultType.equals("INT") || !nextType.equals("INT")) {
                // Special case: String concatenation with +
                if (operator.equals("+") && resultType.equals("STRING") && nextType.equals("STRING")) {
                    // String concatenation is allowed
                    resultType = "STRING";
                } else {
                    this.errorLogger.addError(new EMJError("invalidMathOperand", 
                        "Operator " + operator + " requires integer operands, found " + 
                        resultType + " and " + nextType, ctx.start.getLine()));
                }
            }
        }
        
        return resultType;
    }
    
    /**
     * Visit a multiplicative expression (*, /)
     * Returns the type of the expression
     */
    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        // Visit the first unary expression
        String resultType = (String) visit(ctx.unaryExpression(0));
        
        // Visit any additional unary expressions (separated by * or /)
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            String nextType = (String) visit(ctx.unaryExpression(i));
            String operator = ctx.MUL(i-1) != null ? "*" : "/";
            
            // Check type compatibility for multiplication/division
            // Only integers can be multiplied or divided
            if (!resultType.equals("INT") || !nextType.equals("INT")) {
                this.errorLogger.addError(new EMJError("invalidMathOperand", 
                    "Operator " + operator + " requires integer operands, found " + 
                    resultType + " and " + nextType, ctx.start.getLine()));
            }
            
            // Check for division by zero if possible
            if (operator.equals("/") && ctx.unaryExpression(i).primary() != null && 
                ctx.unaryExpression(i).primary().INT_LITERAL() != null) {
                String literal = ctx.unaryExpression(i).primary().INT_LITERAL().getText();
                if (literal.equals("0")) {
                    this.errorLogger.addError(new EMJError("invalidDivision", 
                        "Division by zero detected", ctx.start.getLine()));
                }
            }
        }
        
        // Multiplicative expressions with integers always return integers
        return resultType;
    }
    
    /**
     * Visit a unary expression (unary minus)
     * Returns the type of the expression
     */
    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // Visit the primary expression
        String exprType = (String) visit(ctx.primaryExpression());
        
        // Check if unary minus is present
        boolean hasUnaryMinus = ctx.MINUS() != null;
        if (hasUnaryMinus) {
            // Verify that the expression is a numeric type
            if (!exprType.equals("INT")) {
                this.errorLogger.addError(new EMJError("invalidUnaryOperand", 
                    "Unary minus requires integer operand, found " + exprType, 
                    ctx.start.getLine()));
            }
            // Unary minus on integer remains an integer
            return "INT";
        }
        
        // If no unary operator, just pass through the type of the primary expression
        return exprType;
    }
    
    /**
     * Visit a primary expression (literals, variables, function calls, etc.)
     */
    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        // Handle different types of primary expressions
        if (ctx.INT_VALUE() != null) {
            // Integer literal
            return "INT";
        } else if (ctx.STRING_VALUE() != null) {
            // String literal
            return "STRING";
        } else if (ctx.CHAR_VALUE() != null) {
            // Character literal
            return "CHAR";
        } else if (ctx.TRUE() != null || ctx.FALSE() != null) {
            // Boolean literal
            return "BOOL";
        } else if (ctx.NOT() != null) {
            // NOT expression
            visit(ctx.primaryExpression());
            return "BOOL";
        } else if (ctx.tupleValue() != null) {
            // Tuple value
            visit(ctx.tupleValue());
            return "TUPLE";
        } else if (ctx.EMOJI_ID() != null) {
            // Variable reference
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);
            if (info == null) {
                errorLogger.addError(new EMJError("varIdNotDecl", 
                    "Variable " + varId + " not declared", ctx.start.getLine()));
                return "UNKNOWN";
            }
            return info.getDataType();
        } else if (ctx.functionCall() != null) {
            // Function call
            return visit(ctx.functionCall());
        } else if (ctx.leftExpression() != null) {
            // Left expression - e.g., array access, struct member
            return visit(ctx.leftExpression());
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return visit(ctx.expression());
        }
        
        // If we get here, it's an unknown type
        this.errorLogger.addError(new EMJError("unknownPrimaryExpressionType", 
            "Unknown type for primary expression", ctx.start.getLine()));
        return "UNKNOWN";
    }
    
    /**
     * Visit a tuple value
     * Checks that tuple elements have valid types
     */
    @Override
    public Object visitTupleValue(EMJParser.TupleValueContext ctx) {
        // Visit all expressions in the tuple
        List<String> elementTypes = new ArrayList<>();
        for (EMJParser.ExpressionContext expr : ctx.expression()) {
            String exprType = (String) visit(expr);
            elementTypes.add(exprType);
        }
        
        // In EMJ, tuples are primarily used for coordinates
        // Check if there are exactly 2 elements and they are both integers
        if (elementTypes.size() != 2) {
            this.errorLogger.addError(new EMJError("invalidTupleSize", 
                "Tuple must have exactly 2 elements, found " + elementTypes.size(), 
                ctx.start.getLine()));
        } else {
            // Verify both elements are integers (for coordinates)
            for (int i = 0; i < elementTypes.size(); i++) {
                if (!elementTypes.get(i).equals("INT")) {
                    this.errorLogger.addError(new EMJError("invalidTupleElementType", 
                        "Tuple element must be an integer, found " + elementTypes.get(i), 
                        ctx.start.getLine()));
                }
            }
        }
        
        return "TUPLE";
    }
    
    /**
     * Visit predefined statements (built-in robot actions)
     * Checks parameters for predefined actions
     */
    @Override
    public Object visitPredefinedStmt(EMJParser.PredefinedStmtContext ctx) {
        if (ctx.expression() != null) {
            // If there's an expression parameter, verify its type is appropriate
            String exprType = (String) visit(ctx.expression());
            
            // For move commands with distance parameter, it should be an integer
            if (!exprType.equals("INT")) {
                this.errorLogger.addError(new EMJError("invalidPredefinedParameter", 
                    "Predefined action parameter must be an integer, found " + exprType, 
                    ctx.start.getLine()));
            }
        }
        
        return null;
    }
    
    /**
     * Visit a function call
     * Verifies that the function exists and that the arguments match the parameters
     * @return The return type of the function
     */
    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        // Get the function name
        String funcId = ctx.EMOJI_ID().getText();
        
        // Look up the function in the symbol table
        EMJSymbolInfo funcInfo = symbolTable.lookup(funcId);
        if (funcInfo == null) {
            // Function not found - report error
            this.errorLogger.addError(new EMJError("funcIdNotDecl", 
                "Function " + funcId + " not declared", ctx.start.getLine()));
            return "UNKNOWN";
        }
        
        // Verify this is actually a function
        if (!funcInfo.isFunction()) {
            this.errorLogger.addError(new EMJError("notAFunction", 
                "Symbol " + funcId + " is not a function", ctx.start.getLine()));
            return "UNKNOWN";
        }
        
        // Get the function's parameter types and return type
        List<String> paramTypes = funcInfo.getParamTypes();
        String returnType = funcInfo.getDataType();
        
        // Get the argument list from the context
        List<EMJParser.ExpressionContext> args = ctx.expressionList() != null ? 
            ctx.expressionList().expression() : new ArrayList<>();
        
        // Check if the number of arguments matches the number of parameters
        if (args.size() != paramTypes.size()) {
            this.errorLogger.addError(new EMJError("invalidArgumentCount", 
                "Function " + funcId + " expects " + paramTypes.size() + 
                " arguments, but got " + args.size(), ctx.start.getLine()));
        } else {
            // Check each argument's type against the corresponding parameter type
            for (int i = 0; i < args.size(); i++) {
                String argType = (String) visit(args.get(i));
                String paramType = paramTypes.get(i);
                
                if (!argType.equals(paramType)) {
                    this.errorLogger.addError(new EMJError("invalidArgumentType", 
                        "Function " + funcId + ": argument " + (i + 1) + " should be " + 
                        paramType + ", but got " + argType, ctx.start.getLine()));
                }
            }
        }
        
        // Return the function's return type
        return returnType;
    }


    /**
     * Visit a map file
     */
    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }



//
//
//    SEMANTIC_VAR_AFFECT
//    */
//    @Override
//    public Object visitVarAffect(EMJParser.VarAffectContext ctx) {
//
//        // SEMANTIC_CHECK_VAR_IS_DECL : Check if an id in a variable affectation has been previously declared
//        String varId = ctx.EMOJI_ID().getText();
//
//        // If the variable id is not contained in the variable id array, add an error
//        if(!this.varIds.contains(varId)) {
//            this.errorLogger.addError(new EMJError("varIdNotDecl", ctx.getText(), ctx.start.getLine()));
//        }
//
//        return null;
//    }
}