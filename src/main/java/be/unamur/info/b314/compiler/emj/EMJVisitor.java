package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJParser;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
 * @author : Alix Decrop
 * @version : 1.0
 * @overview Visiteur ANTLR pour l'analyse sémantique du langage EMJ, mutable.
 * @specfield errorLogger : EMJErrorLogger — collecte les erreurs sémantiques
 * @specfield symbolTable : EMJSymbolTable — gère les symboles et portées
 * 
 * @invariant errorLogger != null
 * @invariant symbolTable != null
 */
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private final EMJErrorLogger errorLogger;
    private final EMJSymbolTable symbolTable;

    /**
     * Constructeur par défaut
     * @effects this_post.errorLogger = new EMJErrorLogger()
     *          this_post.symbolTable = new EMJSymbolTable()
     */
    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
    }

    /**
     * Retourne le logger d'erreurs utilisé par ce visiteur
     * @return this.errorLogger
     */
    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }

    /**
     * Visite le fichier de programme principal
     * @param ctx Contexte du fichier programme
     * @requires ctx != null
     * @effects visite chaque déclaration de fonction dans le fichier
     *          vérifie que la fonction main existe et est du bon type
     * @return null
     */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx){
        //TODO : visitImportMap ? On gère comment pour la suite ?

        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            visitFunctionDecl(functionDeclContext);
        }

        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            if (!checkDeclaration(functionDeclContext)){
                return null;
            }
        }

        if (ctx.mainFunction() == null) {
            errorLogger.addError(new EMJError("Main function is null", ctx.getText(), ctx.start.getLine()));
        }else {
            visit(ctx.mainFunction());
        }
        return null;
    }

    /**
     * Vérifie la cohérence de la déclaration de fonction
     * @param ctx Contexte de la déclaration de fonction
     * @requires ctx != null && ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null
     * @modifies symbolTable.currentScope
     * @effects vérifie que le type de retour de la fonction correspond à sa déclaration
     *          ajoute une erreur au errorLogger si les types ne correspondent pas
     * @return true si le type de retour correspond à la déclaration, false sinon
     */
    private boolean checkDeclaration(EMJParser.FunctionDeclContext ctx) {
        EMJSymbolInfo declaredInfo = symbolTable.lookup(ctx.EMOJI_ID().getText());
        if (declaredInfo == null) {
            errorLogger.addError(new EMJError(String.format("No declaration information for function %s in the symbol table", ctx.EMOJI_ID()), ctx.getText(), ctx.start.getLine()));
            return false;
        }
        symbolTable.enterScope("function_" + declaredInfo.getId());
        String expectedReturn = declaredInfo.getReturnType();
        String actualReturn = EMJVarType.UNKNOWN.label(); //Valeur garantissant un état cohérent en cas d'échec silencieux
        if (isAVoidReturn(ctx)) {
            actualReturn = EMJVarType.VOID.label();
        } else {
            EMJParser.ExpressionContext returnStmtExpression = ctx.returnStatement().expression();
            if (returnStmtExpression == null) {
                errorLogger.addError(new EMJError(String.format("Function %s has a null return statement (expected %s) .", declaredInfo.getId(), expectedReturn), ctx.getText(), ctx.start.getLine()));
                symbolTable.exitScope();
                return false;
            }
            actualReturn = getExpressionType(returnStmtExpression);
        }
        symbolTable.exitScope();
        if (!areTypesCompatible(expectedReturn, actualReturn)) {
            errorLogger.addError(new EMJError(String.format("Function %s returns %s instead of %s .", declaredInfo.getId(), actualReturn, expectedReturn), ctx.getText(), ctx.start.getLine()));
            return false;
        }
        return true;
    }

    /**
     * Vérifie si une déclaration de fonction a un retour de type void
     * @param ctx Contexte de la déclaration de fonction
     * @requires ctx != null && ctx.returnStatement() != null
     * @return true si l'instruction de retour est de type void, false sinon
     */
    private static boolean isAVoidReturn(EMJParser.FunctionDeclContext ctx) {
        return ctx.returnStatement().VOID_TYPE() != null || ctx.returnStatement().RETURN_VOID() != null
                || ctx.returnStatement().expression() == null || ctx.returnStatement().expression().isEmpty();
    }

    /**
     * Visite une déclaration de variable
     * @param ctx Contexte de la déclaration de variable
     * @requires ctx != null && ctx.EMOJI_ID() != null && ctx.type() != null
     * @effects ajoute une variable dans la table des symboles
     *          vérifie la compatibilité de type si une expression d'initialisation est présente
     *          ajoute une erreur au errorLogger si le nom est déjà déclaré dans la même portée
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return null
     */
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        EMJSymbolInfo varInTable = this.symbolTable.lookup(varId);
        if (varInTable != null) {
            if (varInTable.getSymbolType() == EMJSymbolType.PARAMETER) {
                errorLogger.addError(new EMJError(
                        "varIdShadowsParameter",
                        String.format("Variable '%s' cannot shadow a parameter in the same function.", varId),
                        ctx.start.getLine()
                ));
            }else {
                this.errorLogger.addError(new EMJError("varIdAlreadyExists", ctx.getText(), ctx.start.getLine()));
            }
            return null;
        }

        String varType = getTypeFromContext(ctx.type());
        if (EMJVarType.UNKNOWN.label().equals(varType)) {
            errorLogger.addError(new EMJError(
                    "unknownVariableType",
                    String.format("Cannot declare variable '%s' with unknown type.", varId),
                    ctx.start.getLine()
            ));
            return null;
        }
        boolean isInitialized = ctx.expression() != null;
        this.symbolTable.addVariable(varId, varType, isInitialized);
        // Need to check type compatibility
        if (isInitialized) {
            // Visit the expression to determine its type
            String exprType = getExpressionType(ctx.expression());

            if (!areTypesCompatible(varType, exprType)) {
                this.errorLogger.addError(new EMJError(
                        "typeMismatch",
                        "Cannot initialize variable of type '" + varType +
                                "' with an expression of type '" + exprType + "'",
                        ctx.start.getLine()
                ));
            }
        }
        return null;
    }

    /**
     * Vérifie la compatibilité entre un type déclaré et un type d'expression
     * @param declaredType Type déclaré
     * @param exprType Type de l'expression
     * @requires declaredType != null && exprType != null
     * @effects vérifie si un type d'expression est compatible avec un type déclaré
     * @return true si les types sont compatibles, false sinon
     *         Les types sont considérés compatibles s'ils sont identiques et non null
     *         Les types "UNKNOWN" sont incompatibles avec tout type
     */
    private boolean areTypesCompatible(String declaredType, String exprType) {
        if (declaredType == null || exprType == null || EMJVarType.UNKNOWN.label().equals(declaredType) || EMJVarType.UNKNOWN.label().equals(exprType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (declaredType.equals(exprType)) {
            return true;
        }

        // Si l'un est un tuple et l'autre ne l'est pas, ils sont incompatibles
        boolean declaredStartsWTuple = declaredType.startsWith(String.format("%s(", EMJVarType.TUPLE));
        boolean exprStartsWTuple = exprType.startsWith(String.format("%s(", EMJVarType.TUPLE));
        if ((declaredStartsWTuple && !exprStartsWTuple) || (!declaredStartsWTuple && exprStartsWTuple)) {
            return false;
        }

        // Pour deux tuples, vérifier la compatibilité des types internes
        if (declaredStartsWTuple && exprStartsWTuple) {
            String declaredInner = declaredType.substring(6, declaredType.length() - 1).trim();
            String exprInner = exprType.substring(6, exprType.length() - 1).trim();
            return areTypesCompatible(declaredInner, exprInner);
        }

        return false;
    }



    /**
     * Vérifie si les types sont compatibles pour une opération de comparaison
     * 
     * @param leftType Type de l'opérande gauche
     * @param rightType Type de l'opérande droite
     * @param ctx Le contexte de la comparaison
     * @requires leftType != null && rightType != null && ctx != null
     * @effects vérifie la compatibilité des types dans une expression de comparaison
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return true si les types sont compatibles pour la comparaison, false sinon
     *         Les types sont compatibles s'ils sont identiques
     *         Les types "UNKNOWN" sont incompatibles avec tout type
     *         Les comparaisons entre types différents sont considérées incompatibles
     */
    private boolean areComparisonTypesCompatible(String leftType, String rightType, EMJParser.ComparisonExpressionContext ctx) {
        // Si l'un des types est inconnu, considérer comme incompatible
        if (leftType == null || rightType == null || leftType.equals(EMJVarType.UNKNOWN.label()) || rightType.equals(EMJVarType.UNKNOWN.label())) {
            return false;
        }

        // Opérateurs == ou != → autoriser des types compatibles, pas seulement identiques
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null) {
            return areTypesCompatible(leftType, rightType);
        }

        // Opérateurs <, <=, >, >= → seulement INT vs INT
        if (ctx.LESS() != null || ctx.LEQ() != null || ctx.GREATER() != null || ctx.GEQ() != null) {
            return leftType.equals(EMJVarType.INT.label()) && rightType.equals(EMJVarType.INT.label());
        }

        // Par défaut, les types sont considérés comme incompatibles
        return false;
    }

    /**
     * Détermine le type EMJ à partir d'un contexte de type.
     *
     * @param typeCtx Contexte de type à analyser.
     * @return le type EMJ correspondant au contexte sous forme de chaîne.
     *         "INT" pour les entiers, "BOOL" pour les booléens, etc.
     *         "TUPLE(type)" pour les tuples, avec le type interne entre parenthèses
     *         "UNKNOWN" si le type n'est pas reconnu
     */
    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx == null) return EMJVarType.UNKNOWN.label();
        if (typeCtx.INT_TYPE() != null) {
            return EMJVarType.INT.label();
        }
        if (typeCtx.BOOL_TYPE() != null) {
            return EMJVarType.BOOL.label();
        }
        if (typeCtx.CHAR_TYPE() != null) {
            return EMJVarType.CHAR.label();
        }
        if (typeCtx.STRING_TYPE() != null) {
            return EMJVarType.STRING.label();
        }
        if (typeCtx.tupleType() != null) {
            EMJParser.TupleTypeContext tupleCtx = typeCtx.tupleType();
            String innerType = getTypeFromContext(tupleCtx.type());
            if (innerType.equals(EMJVarType.UNKNOWN.label())) {
                return EMJVarType.UNKNOWN.label();//TODO : on autorise "Tuple(UNKNOWN)" ? si oui, enlever ce if
            }
            return String.format("%s(%s)", EMJVarType.TUPLE.label(), innerType);
        }
        return EMJVarType.UNKNOWN.label();
    }



    /**
     * Détermine le type d'une expression
     * @param ctx Contexte de l'expression
     * @requires ctx != null
     * @return le type de l'expression sous forme de chaîne
     *         retourne "UNKNOWN" si le type n'a pas pu être déterminé
     */
    private String getExpressionType(EMJParser.ExpressionContext ctx) {
        // Visiter l'expression et récupérer le résultat
        Object result = visit(ctx);

        if (!(result instanceof String)) {
            errorLogger.addError(new EMJError(
                    "invalidExpressionTyping",
                    String.format("Expression did not produce a valid type: %s", ctx.getText()),
                    ctx.getStart().getLine()
            ));
            return EMJVarType.UNKNOWN.label();
        }

        return (String) result;
    }

    /**
     * Visite une expression
     * @param ctx Contexte de l'expression
     * @requires ctx != null
     * @effects délègue la visite à la méthode orExpression
     * @return le type de l'expression sous forme de chaîne, jamais null
     */
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Déléguer à la méthode de visite pour orExpression
        return visit(ctx.orExpression());
    }

    /**
     * Visite une expression OR
     * @param ctx Contexte de l'expression OR
     * @requires ctx != null
     * @effects visite les expressions composant l'expression OR
     *          vérifie que les opérandes sont de type BOOL
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type BOOL
     * @return le type de l'expression, "BOOL" si c'est une expression OR,
     *         le type de la sous-expression si c'est une expression simple,
     *         "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // S'il y a plus d'une andExpression connectée par OR, c'est un booléen
        if (!ctx.OR().isEmpty()) {
            boolean hasTypeError = false;

            // Vérifier chaque opérande
            for (EMJParser.AndExpressionContext andExpr : ctx.andExpression()) {
                String type = (String) visit(andExpr);
                if (!type.equals(EMJVarType.BOOL.label()) && !type.equals(EMJVarType.UNKNOWN.label())) {//TODO: UNKNOWN ????
                    errorLogger.addError(new EMJError(
                            "invalidBooleanOperand",
                            String.format("Operand of OR must be of type BOOL, found: %s", type),
                            ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }

            return hasTypeError ? EMJVarType.UNKNOWN.label() : EMJVarType.BOOL.label();
        }

        // Sinon, déléguer au premier andExpression
        return visit(ctx.andExpression(0));
    }

    /**
     * Visite une expression AND
     * @param ctx Contexte de l'expression AND
     * @requires ctx != null
     * @effects visite les expressions composant l'expression AND
     *          vérifie que les opérandes sont de type BOOL
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type BOOL
     * @return le type de l'expression, "BOOL" si c'est une expression AND,
     *         le type de la sous-expression si c'est une expression simple,
     *         "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // S'il y a plus d'une notExpression connectée par AND, c'est un booléen
        if (!ctx.AND().isEmpty()) {
            boolean hasTypeError = false;

            // Vérifier chaque opérande
            for (EMJParser.NotExpressionContext notExpr : ctx.notExpression()) {
                String type = (String) visit(notExpr);
                if (!type.equals(EMJVarType.BOOL.label()) && !type.equals(EMJVarType.UNKNOWN.label())) {//TODO: UNKNOWN ????
                    errorLogger.addError(new EMJError(
                        "invalidBooleanOperand",
                            String.format("Operand of AND must be of type BOOL, found: %s", type),
                        ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }

            return hasTypeError ? EMJVarType.UNKNOWN.label() : EMJVarType.BOOL.label();
        }

        // Sinon, déléguer au premier notExpression
        return visit(ctx.notExpression(0));
    }

    /**
     * Visite une expression de négation (NOT)
     * @param ctx Contexte de l'expression NOT
     * @requires ctx != null
     * @ensures ctx.NOT() == null ==> \result == visit(ctx.comparisonExpression())
     * @ensures ctx.NOT() != null && visit(ctx.comparisonExpression()).equals("BOOLEAN") ==>
     *         \result.equals("BOOLEAN")
     * @assignable \nothing
     */
    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // S'il y a un NOT, c'est un booléen
        if (ctx.NOT() != null) {
            String type = (String) visit(ctx.comparisonExpression());
            if (!type.equals(EMJVarType.BOOL.label()) && !type.equals(EMJVarType.UNKNOWN.label())) {//TODO: UNKNOWN ????
                errorLogger.addError(new EMJError(
                    "invalidNotOperand",
                        String.format("Operand of NOT must be of type BOOL, found: %s", type),
                    ctx.start.getLine()
                ));
                return EMJVarType.UNKNOWN.label();
            }
            return EMJVarType.BOOL.label();
        }

        // Sinon, déléguer à comparisonExpression
        return visit(ctx.comparisonExpression());
    }

    /**
     * Visite une expression de comparaison
     * @param ctx Contexte de l'expression de comparaison
     * @requires ctx != null
     * @effects visite les expressions additives dans l'expression de comparaison
     *          vérifie que les opérandes des opérateurs de comparaison ont des types compatibles
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return le type de l'expression de comparaison:
     *         - le type de la sous-expression si c'est une expression simple
     *         - "BOOL" si c'est une comparaison avec des opérandes de types compatibles
     *         - "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // S'il y a un opérateur de comparaison, c'est un booléen
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null ||
                ctx.LESS() != null || ctx.LEQ() != null ||
                ctx.GREATER() != null || ctx.GEQ() != null) {
            // Récupérer les types des opérandes de la comparaison
            String leftType = (String) visit(ctx.additiveExpression(0));
            String rightType = (String) visit(ctx.additiveExpression(1));
            if (leftType == null || rightType == null) {
                errorLogger.addError(new EMJError(
                        "nullOperand",
                        String.format("Cannot compare: one of the operands is null (left: %s, right: %s).", leftType, rightType),
                        ctx.start.getLine()
                ));
                return EMJVarType.UNKNOWN.label();
            }

            // Vérifier la compatibilité des types pour l'opération de comparaison
            if (!areComparisonTypesCompatible(leftType, rightType, ctx)) {
                // Ajouter une erreur sémantique si les types sont incompatibles
                errorLogger.addError(new EMJError(
                        "incompatibleComparisonTypes",
                        String.format("Cannot compare values of incompatible types: '%s' and '%s'", leftType, rightType),
                        ctx.start.getLine()
                ));
                return EMJVarType.UNKNOWN.label(); // Retourner UNKNOWN au lieu de BOOL quand les types sont incompatibles
            }

            return EMJVarType.BOOL.label();
        }

        // Cas sans opérateur de comparaison, on envoie à la sous-expression unique
        return visit(ctx.additiveExpression(0));
    }



    /**
     * Visite une expression additive
     * @param ctx Contexte de l'expression additive
     * @requires ctx != null
     * @effects visite les expressions multiplicatives dans l'expression additive
     *          vérifie que les opérandes des opérateurs + et - sont de type INT
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type INT
     * @return le type de l'expression additive:
     *         - le type de la sous-expression si c'est une expression simple
     *         - "INT" si tous les opérandes sont de type INT
     *         - "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // On commence par le premier opérande
        Object leftObj = visit(ctx.multiplicativeExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : EMJVarType.UNKNOWN.label();

        if (ctx.multiplicativeExpression().size() == 1) {
            return leftType;
        }

        boolean hasTypeError = false;
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            Object rightObj = visit(ctx.multiplicativeExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : EMJVarType.UNKNOWN.label();

            // Vérifie que les deux opérandes sont des entiers
            if (!leftType.equals(EMJVarType.INT.label()) || !rightType.equals(EMJVarType.INT.label())) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        String.format("Operands of '+' or '-' must be of type INT, found: %s and %s", leftType, rightType),
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // Pour les itérations suivantes - ne pas forcer le type si erreur
            if (!hasTypeError) {
                leftType =  EMJVarType.INT.label();
            } else {//TODO: vérifier les effets de bord provoqués ici
                leftType =  EMJVarType.UNKNOWN.label();
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? EMJVarType.UNKNOWN.label() : EMJVarType.INT.label();
    }

    /**
     * Visite une expression multiplicative (*, /)
     * @param ctx Contexte de l'expression multiplicative
     * @requires ctx != null
     * @ensures ctx.unaryExpression().size() <= 1 ==> \result == visit(ctx.unaryExpression(0))
     * @ensures ctx.unaryExpression().size() > 1 && ctx.DIV() != null &&
     *         visit(ctx.unaryExpression(0)).equals("INT") &&
     *         visit(ctx.unaryExpression(1)).equals("INT") ==>
     *         \result.equals("INT")
     * @assignable \nothing
     */
    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        Object leftObj = visit(ctx.unaryExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj :  EMJVarType.UNKNOWN.label();
        if (ctx.unaryExpression().size() == 1) {
            return leftType;
        }

        boolean hasTypeError = false;

        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            Object rightObj = visit(ctx.unaryExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : EMJVarType.UNKNOWN.label();

            // Si l'un des opérandes a déjà une erreur de type, propager l'erreur
            if (leftType.equals(EMJVarType.UNKNOWN.label()) || rightType.equals(EMJVarType.UNKNOWN.label())) {
                return EMJVarType.UNKNOWN.label();
            }

            // Vérification spécifique pour la division
            if (ctx.DIVIDE(i - 1) != null) {
                // Vérifier que les deux types sont INT
                if (!leftType.equals(EMJVarType.INT.label()) || !rightType.equals(EMJVarType.INT.label())) {
                    // Cas spécial: division d'une chaîne par un nombre, erreur sémantique
                    if (leftType.equals(EMJVarType.STRING.label()) && rightType.equals(EMJVarType.INT.label())) {
                        errorLogger.addError(new EMJError(
                                "invalidDivisionOperation",
                                String.format("Cannot divide a STRING by an INT: '%s' / '%s'", leftType, rightType),
                                ctx.start.getLine()
                        ));

                    } else {
                        errorLogger.addError(new EMJError(
                                "invalidOperandType",
                                String.format("Operands of '*' or '/' must be of type INT, found: %s and %s", leftType, rightType),
                                ctx.start.getLine()
                        ));
                    }
                    hasTypeError = true;
                }

                // Vérification de division par zéro
                EMJParser.UnaryExpressionContext rightExpr = ctx.unaryExpression(i);
                if (rightExpr.primaryExpression() != null && rightExpr.primaryExpression().INT_VALUE() != null) {
                    String valueText = rightExpr.primaryExpression().INT_VALUE().getText();
                    try {
                        int val = Integer.parseInt(valueText);
                        if (val == 0) {
                            errorLogger.addError(new EMJError(
                                    "divisionByZero",
                                    "Division by zero is not allowed.",
                                    ctx.start.getLine()
                            ));
                            hasTypeError = true;
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            } else {
                // Pour la multiplication, vérifier simplement que les deux types sont INT
                if (!leftType.equals(EMJVarType.INT.label()) || !rightType.equals(EMJVarType.INT.label())) {
                    errorLogger.addError(new EMJError(
                            "invalidOperandType",
                            String.format("Operands of '*' must be of type INT, found: %s and %s", leftType, rightType),
                            ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }

            // Ne pas forcer le type à INT si une erreur a été détectée
            if (!hasTypeError) {
                leftType = EMJVarType.INT.label();
            } else {//TODO: vérifier les effets de bord provoqués ici
                leftType = EMJVarType.UNKNOWN.label();
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? EMJVarType.UNKNOWN.label() : EMJVarType.INT.label();
    }

    /**
     * Visite une expression unaire (-, +)
     * @param ctx Contexte de l'expression unaire
     * @requires ctx != null
     * @ensures ctx.SUB() == null ==> \result == visit(ctx.primaryExpression())
     * @ensures ctx.SUB() != null && visit(ctx.primaryExpression()).equals("INT") ==>
     *         \result.equals("INT")
     * @assignable \nothing
     */
    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // S'il y a un - unaire, c'est un entier
        if (ctx.MINUS() != null) {
            return  EMJVarType.INT.label();
        }

        // Sinon, déléguer à primaryExpression
        return visit(ctx.primaryExpression());
    }

    /**
     * Visite une expression primaire (littéraux, identifiants, appels de fonction)
     * @param ctx Contexte de l'expression primaire
     * @requires ctx != null
     * @ensures ctx.INT_LITERAL() != null ==> \result.equals("INT")
     * @ensures ctx.TRUE() != null || ctx.FALSE() != null ==> \result.equals("BOOLEAN")
     * @ensures ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null ==>
     *         \result.equals(symbolTable.lookup(ctx.EMOJI_ID().getText()).getType())
     * @ensures ctx.functionCall() != null ==> \result == visit(ctx.functionCall())
     * @ensures ctx.expression() != null ==> \result == visit(ctx.expression())
     * @assignable \nothing
     * @return le type de l'expression primaire
     */
    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        if (ctx.INT_VALUE() != null) {
            String intValue = ctx.INT_VALUE().getText();

            if (intValue.length() > 1 && intValue.charAt(0) == '0') {
                errorLogger.addError(new EMJError(
                        "intStartsWithZero",
                        String.format("Integer value cannot start with 0: %s", intValue),
                        ctx.start.getLine()));
            }

            try {
                long val = Long.parseLong(intValue);
                if (val > 1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooBig",
                            String.format("Integer value too big: %s", intValue),
                            ctx.start.getLine()));
                } else if (val < -1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooSmall",
                            String.format("Integer value too small: %s", intValue),
                            ctx.start.getLine()));
                }
            } catch (NumberFormatException e) {
                errorLogger.addError(new EMJError(
                        "invalidIntegerFormat",
                        String.format("Invalid integer format: %s", intValue),
                        ctx.start.getLine()));
            }
            return EMJVarType.INT.label();
        }

        if (ctx.STRING_VALUE() != null) return EMJVarType.STRING.label();
        if (ctx.CHAR_VALUE()   != null) return EMJVarType.CHAR.label();
        if (ctx.TRUE() != null || ctx.FALSE() != null) return EMJVarType.BOOL.label();

        if (ctx.tupleValue() != null) {
            String t1 = (String) visit(ctx.tupleValue().expression(0));
            String t2 = (String) visit(ctx.tupleValue().expression(1));
            if (!t1.equals(t2)) {
                errorLogger.addError(new EMJError(
                        "tupleMismatchedTypes",
                        String.format("Tuple elements must have the same type, found: %s and %s", t1, t2),
                        ctx.start.getLine()));
            }
            if (t1.equals(EMJVarType.UNKNOWN.label()) || t2.equals(EMJVarType.UNKNOWN.label())) {
                return EMJVarType.UNKNOWN.label(); //TODO : on autorise "Tuple(UNKNOWN)" ? si oui, enlever ce if
            }
            return String.format("%s(%s)", EMJVarType.TUPLE.label(), t1);
        }

        if (ctx.EMOJI_ID() != null) {
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        String.format("Variable '%s' is not declared", varId),
                        ctx.start.getLine()));
                return  EMJVarType.UNKNOWN.label();
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        String.format("Variable '%s' is used before being initialized", varId),
                        ctx.start.getLine()));
                return  EMJVarType.UNKNOWN.label();
            }
            return info.getType();
        }

        if (ctx.leftExpression() != null) {
            EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
            String varId = leftCtx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        String.format("Variable '%s' is not declared", varId),
                        ctx.start.getLine()));
                return  EMJVarType.UNKNOWN.label();
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        String.format("Tuple '%s' is used before being initialized", varId),
                        ctx.start.getLine()));
                return  EMJVarType.UNKNOWN.label();
            }
            return getLeftExpressionType(leftCtx);
        }

        if (ctx.functionCall() != null) {
            return visitFunctionCall(ctx.functionCall());
        }

        if (ctx.expression() != null) {
            return visit(ctx.expression());
        }

        if (ctx.NOT() != null && ctx.primaryExpression() != null) {
            String t = (String) visit(ctx.primaryExpression());
            if (!t.equals(EMJVarType.BOOL.label())) {
                errorLogger.addError(new EMJError(
                        "invalidNegationOperand",
                        String.format("Operand of NOT must be of type BOOL, found: %s", t),
                        ctx.start.getLine()));
                return EMJVarType.UNKNOWN.label();
            }
            return EMJVarType.BOOL.label();
        }

        return EMJVarType.UNKNOWN.label();
    }

    /**
     * Méthode auxiliaire pour obtenir le type d'une expression gauche
     * @param ctx Contexte de l'expression gauche
     * @requires ctx != null
     * @ensures ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null ==>
     *         \result.equals(symbolTable.lookup(ctx.EMOJI_ID().getText()).getType())
     * @return Le type de l'expression gauche
     * @pure
     */
    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        EMJSymbolInfo info = symbolTable.lookup(varId);

        if (info == null) {
            errorLogger.addError(new EMJError(
                    "undeclaredVariable",
                    String.format("Variable '%s' is not declared", varId),
                    ctx.getStart().getLine()
            ));
            return  EMJVarType.UNKNOWN.label();
        }

        String varType = info.getType();

        // Si on accède à un élément d'un tuple
        if (ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null) {
            if (!varType.startsWith(String.format("%s(",EMJVarType.TUPLE.label()))) {
                errorLogger.addError(new EMJError(
                        "invalidTupleAccess",
                        String.format("Cannot access tuple element from non-tuple variable '%s'", varId),
                        ctx.getStart().getLine()
                ));
                return  EMJVarType.UNKNOWN.label();
            }

            // Extraire le type interne du tuple (ce qui est entre parenthèses)
            return extractInnerTypeFromTuple(varType);
        }

        return varType;
    }

    /**
     * Extrait le type interne d'un type tuple, si valide.
     *
     * @param type Chaîne représentant un type (ex : "TUPLE(INT)")
     * @return Le type interne (ex : "INT") si format valide, "UNKNOWN" sinon.
     */
    private String extractInnerTypeFromTuple(String type) {
        String tuplePrefix = String.format("%s(", EMJVarType.TUPLE.label());

        if (type == null || !type.startsWith(tuplePrefix) || !type.endsWith(")")) {
            return EMJVarType.UNKNOWN.label();
        }

        // Extraire la sous-chaîne entre les parenthèses
        String inner = type.substring(tuplePrefix.length(), type.length() - 1).trim();

        // Vérification minimale (non vide)
        if (inner.isEmpty()) {
            return EMJVarType.UNKNOWN.label();
        }

        return inner;
    }

    /**
     * Visite une carte
     * @param ctx Contexte de la carte
     * @requires ctx != null
     * @effects vérifie que la carte est valide
     * @return null
     */
    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    String.format("The map must at least have a width >= 2 and a height >= 2 (current : %d x %d).", width, height),
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    String.format("The size given (%d x %d = %d cells) don't match with the number of cells given (%d).", width, height, expectedCellCount, actualCellCount),
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    String.format("The map must contain exactly 1 Police Car, found : %d", policeCarCount),
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    String.format("The map must contain at least 1 Thief, found : %d", thiefCount),
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    String.format("The map must contain at least 1 Road, found : %d", roadCount),
                    ctx.start.getLine()
            ));
        }

        return null;
    }

    /**
     * Visite la fonction principale
     * @param ctx Contexte de la fonction principale
     * @requires ctx != null
     * @modifies rien
     * @effects visite la fonction principale du programme
     * @return le résultat de la visite des enfants du nœud
     */
    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {
        //TODO : checker la structure du main (pas de param, type de retour void au moins une instruction) ?
        symbolTable.enterScope("main");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    /**
     * Visite une déclaration de fonction
     * @param ctx Contexte de la déclaration de fonction
     * @requires ctx != null && ctx.EMOJI_ID() != null
     * @modifies symbolTable
     * @effects ajoute une nouvelle déclaration de fonction à la table des symboles
     *          entre dans une nouvelle portée pour cette fonction
     *          ajoute les paramètres de la fonction à la table des symboles
     * @ensures symbolTable.functionExists(ctx.EMOJI_ID().getText())
     * @return le résultat de la visite des enfants du nœud
     */
    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        // Récupérer l'identifiant de la fonction
        String funcId = ctx.EMOJI_ID().getText();

        // Récupérer le type de retour
        String returnType = getTypeFromContext(ctx.returnType());

        // Récupérer les paramètres & vérifier qu'il n'y a pas de dupes ni d'unknown
        List<EMJParameterInfo> parameters = new ArrayList<>();
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            EMJParser.ParamListContext paramListCtx = ctx.optionalParamList().paramList();
            Set<String> seenParamIds = new HashSet<>();
            for (EMJParser.ParamContext paramCtx : paramListCtx.param()) {
                String paramId = paramCtx.EMOJI_ID().getText();
                String paramType = getTypeFromContext(paramCtx.type());

                if (EMJVarType.UNKNOWN.label().equals(paramType)) {
                    errorLogger.addError(new EMJError(
                            "unknownParameterType",
                            String.format("Parameter '%s' has an unknown type.", paramId),
                            paramCtx.getStart().getLine()
                    ));
                    continue; // on n’ajoute pas ce paramètre
                }

                if (seenParamIds.contains(paramId)) {
                    errorLogger.addError(new EMJError(
                            "duplicateParameter",
                            String.format("Parameter '%s' is declared multiple times in function '%s'.", paramId, funcId),
                            paramCtx.getStart().getLine()
                    ));
                } else {
                    seenParamIds.add(paramId);
                    parameters.add(new EMJParameterInfo(paramId, paramType));
                }
            }
        }

        // Vérifier si la fonction existe déjà
        if (symbolTable.functionExists(funcId)) {
            errorLogger.addError(new EMJError("functionAlreadyDefined",
                    String.format("Function '%s' is already defined", funcId), ctx.start.getLine()));
            return null;
        }

        // Ajouter la fonction à la table des symboles
        symbolTable.addFunction(funcId, returnType, parameters);

        // Entrer dans la portée de la fonction
        symbolTable.enterScope("function_" + funcId);

        // Ajouter les paramètres dans la portée de la fonction
        for (EMJParameterInfo param : parameters) {
            symbolTable.addVariable(param.getId(), param.getType(), true);
        }

        // Visiter le corps de la fonction
        Object result = visitChildren(ctx);

        // Sortir de la portée de la fonction
        symbolTable.exitScope();

        return result;
    }

    /**
     * Méthode auxiliaire pour obtenir le type à partir d'un contexte de type de retour
     *
     * @param ctx Contexte de type de retour
     * @requires ctx != null
     * @modifies rien
     * @return la chaîne de caractères représentant le type, jamais null
     * @ensures si ctx.INT_TYPE() != null alors le résultat est "INT"
     * @ensures si ctx.BOOLEAN_TYPE() != null alors le résultat est "BOOLEAN"
     * @ensures si ctx.VOID_TYPE() != null alors le résultat est "VOID"
     */
    private String getTypeFromContext(EMJParser.ReturnTypeContext ctx) {
        if (ctx.VOID_TYPE() != null) {
            return EMJVarType.VOID.label();
        }
        if (ctx.type() != null) {
            return getTypeFromContext(ctx.type());
        }
        return  EMJVarType.UNKNOWN.label();
    }


    /**
     * Visite une instruction de boucle
     *
     * @param ctx Contexte de l'instruction de boucle
     * @requires ctx != null && ctx.expression() != null
     * @modifies symbolTable, errorLogger
     * @effects entre dans une nouvelle portée "loop"
     *          vérifie que l'expression de condition est de type BOOLEAN
     *          ajoute une erreur si la condition n'est pas de type BOOLEAN
     * @ensures getExpressionType(ctx.expression()).equals("BOOLEAN") || errorLogger.hasErrors()
     * @return le résultat de la visite des enfants du nœud
     */
    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {
        symbolTable.enterScope("loop");

        if (ctx.expression() != null) {
            String condType = getExpressionType(ctx.expression());
            if (!condType.equals(EMJVarType.BOOL.label()) && !condType.equals(EMJVarType.INT.label())) {
                errorLogger.addError(new EMJError(
                        "invalidLoopCondition",
                        String.format("Loop condition must be of type BOOL or INT, found: %s", condType),
                        ctx.start.getLine()
                ));
            }
        } else {
            errorLogger.addError(new EMJError(
                    "missingLoopCondition",
                    "Loop statement requires a condition expression.",
                    ctx.start.getLine()
            ));
        }

        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {
        symbolTable.enterScope("if");

        if (ctx.expression() != null) {
            String condType = getExpressionType(ctx.expression());
            if (!condType.equals(EMJVarType.BOOL.label())) {
                errorLogger.addError(new EMJError(
                        "invalidIfCondition",
                        String.format("Condition of if statement must be of type BOOL, found: %s", condType),
                        ctx.start.getLine()
                ));
            }
        } else {
            errorLogger.addError(new EMJError(
                    "missingIfCondition",
                    "If statement requires a condition expression.",
                    ctx.start.getLine()
            ));
        }

        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    /**
     * Visite un bloc de code
     *
     * @param ctx Contexte du bloc de code
     * @requires ctx != null
     * @modifies symbolTable
     * @effects entre dans une nouvelle portée "block"
     * @return le résultat de la visite des enfants du nœud
     */
    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {

        symbolTable.enterScope("block");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }


    /**
     * Visite une instruction d'affectation
     *
     * @param ctx Contexte de l'instruction d'affectation
     * @requires ctx != null && ctx.leftExpression() != null && ctx.expression() != null
     * @modifies errorLogger, symbolTable
     * @effects vérifie que la variable à gauche est déclarée
     *          vérifie que les types sont compatibles
     *          marque la variable comme initialisée (si elle n'est pas une composante de tuple)
     *          ajoute des erreurs au errorLogger si nécessaire
     * @ensures si la variable est trouvée dans la table des symboles, elle est marquée comme initialisée
     * @return null
     */
    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
        String varId = leftCtx.EMOJI_ID().getText();

        EMJSymbolInfo varInfo = symbolTable.lookup(varId);
        if (varInfo == null) {
            errorLogger.addError(new EMJError(
                    "varIdNotDecl",
                    ctx.getText(),
                    ctx.start.getLine()));
            return null;
        }

        if (ctx.expression() == null) {
            errorLogger.addError(new EMJError(
                    "missingAssignmentExpression",
                    "Assignment is missing a right-hand side expression.",
                    ctx.start.getLine()
            ));
            return null;
        }


        String leftType  = getLeftExpressionType(leftCtx);
        String rightType = getExpressionType(ctx.expression());

        if (!areTypesCompatible(leftType, rightType)) {
            errorLogger.addError(new EMJError(
                    "typeMismatch",
                    String.format("Cannot assign value of type '%s' to target of type '%s'", rightType, leftType),
                    ctx.start.getLine()));
            return null;
        }

        if (leftCtx.TUPLE_FIRST() == null && leftCtx.TUPLE_SECOND() == null) {
            varInfo.setInitialized(true);
        }

        return null;
    }

    /**
     * Visite un appel de fonction
     * @param ctx Contexte de l'appel de fonction
     * @requires ctx != null && ctx.EMOJI_ID() != null
     * @effects vérifie que la fonction appelée est déclarée dans la table des symboles
     *          vérifie que le nombre et les types des arguments correspondent aux paramètres déclarés
     *          vérifie que les fonctions void ne sont pas utilisées dans des expressions
     *          ajoute des erreurs au errorLogger si:
     *            - la fonction n'est pas déclarée
     *            - une fonction void est utilisée dans une expression
     *            - le nombre d'arguments ne correspond pas
     *            - les types des arguments sont incompatibles avec les types des paramètres
     * @return le type de retour de la fonction si elle est déclarée, "UNKNOWN" sinon
     */
    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String functionName = ctx.EMOJI_ID().getText(); // Retrieve the name of the called function

        // Retrieve the number of arguments passed to the function call
        List<EMJParser.ExpressionContext> args =
                ctx.argumentList() != null ? ctx.argumentList().expression() : new ArrayList<>();

        // Retrieve the function definition from the symbol table
        EMJSymbolInfo functionSymbol = symbolTable.lookup(functionName);

        if (functionSymbol == null || functionSymbol.getSymbolType() != EMJSymbolType.FUNCTION) {
            errorLogger.addError(new EMJError("Function not declared", functionName, ctx.getStart().getLine()));
            return  EMJVarType.UNKNOWN.label();
        }

        // Vérifier si la fonction est de type void et si elle est appelée dans une expression
        if (EMJVarType.VOID.label().equals(functionSymbol.getReturnType())) {
            // Pour les fonctions void, vérifier si elles sont utilisées dans une expression
            // Nous considérons tout contexte autre qu'une instruction directe comme une expression
            boolean isUsedInExpression = !(ctx.getParent() instanceof EMJParser.FunctionCallStmtContext);

            if (isUsedInExpression) {
                // Ajouter une erreur sémantique pour l'utilisation d'une fonction void dans une expression
                errorLogger.addError(new EMJError(
                    "voidFunctionInExpression",
                        String.format("Function %s has void return type and cannot be used in an expression", functionName),
                    ctx.getStart().getLine()
                ));
            }
        }

        int expected = functionSymbol.getParameters() != null ? functionSymbol.getParameters().size() : 0;
        int actual = args.size();
        if (actual != expected) {
            errorLogger.addError(new EMJError(
                    actual < expected ? "functionTooFewParameters" : "functionTooManyParameters",
                    String.format("Function '%s' expects %d parameter(s), but got %d", functionName, expected, actual),
                    ctx.getStart().getLine()
            ));
        }

        // Visit each argument expression to perform semantic checks
        for (int i = 0; i < Math.min(actual, expected); i++) {
            String argType = (String) visit(args.get(i));
            String paramType = functionSymbol.getParameters().get(i).getType();
            if (!areTypesCompatible(paramType, argType)) {
                errorLogger.addError(new EMJError(
                        "paramTypeMismatch",
                        String.format("Parameter %d of function %s expects type %s but got %s", i + 1, functionName, paramType, argType),
                        ctx.getStart().getLine()
                ));
            }
        }

        // Return the function's return type
        return functionSymbol.getReturnType();
    }
}