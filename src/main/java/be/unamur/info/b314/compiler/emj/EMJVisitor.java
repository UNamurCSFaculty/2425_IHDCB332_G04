package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJParser;

import java.util.ArrayList;
import java.util.List;

/**
 * Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
 * @author : Alix Decrop
 * @version : 1.0
 * @overview Visiteur ANTLR pour l'analyse sémantique du langage EMJ, mutable.
 * @specfield errorLogger : EMJErrorLogger — collecte les erreurs sémantiques
 * @specfield symbolTable : EMJSymbolTable — gère les symboles et portées
 * 
 * @invariant errorLogger != null
 * @invariant symbolTable != null
 */
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private final EMJErrorLogger errorLogger;
    private final EMJSymbolTable symbolTable;

    /**
     * @effects this_post.errorLogger = new EMJErrorLogger()
     *          this_post.symbolTable = new EMJSymbolTable()
     */
    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
    }

    /**
     * @return this.errorLogger
     */
    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }

    /**
     * @requires ctx != null
     * @effects visite chaque déclaration de fonction dans le fichier
     *          vérifie que la fonction main existe et est du bon type
     * @return null
     */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx){
        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            visitFunctionDecl(functionDeclContext);
        }

        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            if (!checkDeclaration(functionDeclContext)){
                return null;
            }
        }

        visit(ctx.mainFunction());
        return null;
    }

    /**
     * @requires ctx != null && ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null
     * @modifies symbolTable.currentScope
     * @effects vérifie que le type de retour de la fonction correspond à sa déclaration
     *          ajoute une erreur au errorLogger si les types ne correspondent pas
     * @return true si le type de retour correspond à la déclaration, false sinon
     */
    private boolean checkDeclaration(EMJParser.FunctionDeclContext ctx) {
        EMJSymbolInfo declaredInfo = symbolTable.lookup(ctx.EMOJI_ID().getText());
        symbolTable.enterScope("function_" + declaredInfo.getId());
        String expectedReturn = declaredInfo.getReturnType();
        String actualReturn;
        if (isAVoidReturn(ctx)) {
            actualReturn = "VOID";
        } else {
            actualReturn = getExpressionType(ctx.returnStatement().expression());
        }
        symbolTable.exitScope();
        if (!expectedReturn.equals(actualReturn)) {
            errorLogger.addError(new EMJError(String.format("Function %s returns %s instead of %s .", declaredInfo.getId(), actualReturn, expectedReturn), ctx.getText(), ctx.start.getLine()));
            return false;
        }
        return true;
    }

    /**
     * @requires ctx != null && ctx.returnStatement() != null
     * @return true si l'instruction de retour est de type void, false sinon
     */
    private static boolean isAVoidReturn(EMJParser.FunctionDeclContext ctx) {
        return ctx.returnStatement().VOID_TYPE() != null || ctx.returnStatement().RETURN_VOID() != null
                || ctx.returnStatement().expression() == null || ctx.returnStatement().expression().isEmpty();
    }

    /**
     * @requires ctx != null && ctx.EMOJI_ID() != null && ctx.type() != null
     * @effects ajoute une variable dans la table des symboles
     *          vérifie la compatibilité de type si une expression d'initialisation est présente
     *          ajoute une erreur au errorLogger si le nom est déjà déclaré dans la même portée
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return null
     */
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", ctx.getText(), ctx.start.getLine()));
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        this.symbolTable.addVariable(varId, varType, isInitialized);
        // Need to check type compatibility
        if (isInitialized) {
            // Visit the expression to determine its type
            String exprType = getExpressionType(ctx.expression());

            if (!areTypesCompatible(varType, exprType)) {
                this.errorLogger.addError(new EMJError(
                        "typeMismatch",
                        "Cannot initialize variable of type '" + varType +
                                "' with an expression of type '" + exprType + "'",
                        ctx.start.getLine()
                ));
            }
        }

        return null;
    }

    /**
     * @requires declaredType != null && exprType != null
     * @effects vérifie si un type d'expression est compatible avec un type déclaré
     * @return true si les types sont compatibles, false sinon
     *         Les types sont considérés compatibles s'ils sont identiques et non null
     *         Les types "UNKNOWN" sont incompatibles avec tout type
     */
    private boolean areTypesCompatible(String declaredType, String exprType) {
        if (declaredType == null || exprType == null || "UNKNOWN".equals(declaredType) || "UNKNOWN".equals(exprType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (declaredType.equals(exprType)) {
            return true;
        }

        // Si l'un est un tuple et l'autre ne l'est pas, ils sont incompatibles
        if (declaredType.startsWith("TUPLE(") && !exprType.startsWith("TUPLE(")) {
            return false;
        }

        if (!declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            return false;
        }

        // Pour deux tuples, vérifier la compatibilité des types internes
        if (declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            String declaredInner = declaredType.substring(6, declaredType.length() - 1).trim();
            String exprInner = exprType.substring(6, exprType.length() - 1).trim();
            return areTypesCompatible(declaredInner, exprInner);
        }

        return false;
    }



    /**
     * Vérifie si les types sont compatibles pour une opération de comparaison
     * 
     * @requires leftType != null && rightType != null && ctx != null
     * @effects vérifie la compatibilité des types dans une expression de comparaison
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return true si les types sont compatibles pour la comparaison, false sinon
     *         Les types sont compatibles s'ils sont identiques
     *         Les types "UNKNOWN" sont incompatibles avec tout type
     *         Les comparaisons entre types différents sont considérées incompatibles
     *         
     * @param leftType Type de l'opérande gauche
     * @param rightType Type de l'opérande droite
     * @param ctx Le contexte de la comparaison
     */
    private boolean areComparisonTypesCompatible(String leftType, String rightType, Object ctx) {
        // Si l'un des types est inconnu, considérer comme incompatible
        if (leftType == null || rightType == null || "UNKNOWN".equals(leftType) || "UNKNOWN".equals(rightType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (leftType.equals(rightType)) {
            return true;
        }

        // Pour les opérateurs ==, != seuls les types identiques sont compatibles
        if (ctx instanceof EMJParser.ComparisonExpressionContext) {
            EMJParser.ComparisonExpressionContext compCtx = (EMJParser.ComparisonExpressionContext) ctx;
            if (compCtx.DOUBLE_EQUAL() != null || compCtx.NOTEQUAL() != null) {
                // Pour ces opérateurs, les types doivent être identiques
                return false;
            }

            // Pour les opérateurs <, <=, >, >=, seuls les types numériques sont compatibles entre eux
            if (compCtx.LESS() != null || compCtx.LEQ() != null || compCtx.GREATER() != null || compCtx.GEQ() != null) {
                // Pour ces opérateurs, les deux opérandes doivent être des nombres
                return "INT".equals(leftType) && "INT".equals(rightType);
            }
        }

        // Par défaut, les types sont considérés comme incompatibles
        return false;
    }
    /*@ requires typeCtx != null;
       @ ensures \result != null;
       @ ensures typeCtx.INT_TYPE() != null ==> \result.equals("INT");
       @ ensures typeCtx.BOOLEAN_TYPE() != null ==> \result.equals("BOOLEAN");
       @ ensures typeCtx.VOID_TYPE() != null ==> \result.equals("VOID");
    /**
     * @requires typeCtx != null
     * @return le type EMJ correspondant au contexte sous forme de chaîne
     *         "INT" pour les entiers, "BOOL" pour les booléens, etc.
     *         "TUPLE(type)" pour les tuples, avec le type interne entre parenthèses
     *         "UNKNOWN" si le type n'est pas reconnu
     */
    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        } else if (typeCtx.tupleType() != null) {
            EMJParser.TupleTypeContext tupleCtx = typeCtx.tupleType();
            String innerType = getTypeFromContext(tupleCtx.type());
            return "TUPLE(" + innerType + ")";
        }
        return "UNKNOWN";
    }



    /**
     * @requires ctx != null
     * @return le type de l'expression sous forme de chaîne
     *         retourne "UNKNOWN" si le type n'a pas pu être déterminé
     */
    private String getExpressionType(EMJParser.ExpressionContext ctx) {
        // Visiter l'expression et récupérer le résultat
        Object result = visit(ctx);

        // Convertir le résultat en type
        if (result instanceof String) {
            return (String) result;
        }

        return "UNKNOWN";
    }
    /**
     * @requires ctx != null
     * @effects délègue la visite à la méthode orExpression
     * @return le type de l'expression sous forme de chaîne, jamais null
     */
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Déléguer à la méthode de visite pour orExpression
        return visit(ctx.orExpression());
    }

    /**
     * @requires ctx != null
     * @effects visite les expressions composant l'expression OR
     *          vérifie que les opérandes sont de type BOOL
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type BOOL
     * @return le type de l'expression, "BOOL" si c'est une expression OR,
     *         le type de la sous-expression si c'est une expression simple,
     *         "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // S'il y a plus d'une andExpression connectée par OR, c'est un booléen
        if (!ctx.OR().isEmpty()) {
            boolean hasTypeError = false;
            
            // Vérifier chaque opérande
            for (EMJParser.AndExpressionContext andExpr : ctx.andExpression()) {
                String type = (String) visit(andExpr);
                if (!"BOOL".equals(type) && !"UNKNOWN".equals(type)) {
                    errorLogger.addError(new EMJError(
                        "invalidBooleanOperand",
                        "Operand of OR must be of type BOOL, found: " + type,
                        ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }
            
            return hasTypeError ? "UNKNOWN" : "BOOL";
        }

        // Sinon, déléguer au premier andExpression
        return visit(ctx.andExpression(0));
    }

    /**
     * @requires ctx != null
     * @effects visite les expressions composant l'expression AND
     *          vérifie que les opérandes sont de type BOOL
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type BOOL
     * @return le type de l'expression, "BOOL" si c'est une expression AND,
     *         le type de la sous-expression si c'est une expression simple,
     *         "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // S'il y a plus d'une notExpression connectée par AND, c'est un booléen
        if (!ctx.AND().isEmpty()) {
            boolean hasTypeError = false;
            
            // Vérifier chaque opérande
            for (EMJParser.NotExpressionContext notExpr : ctx.notExpression()) {
                String type = (String) visit(notExpr);
                if (!"BOOL".equals(type) && !"UNKNOWN".equals(type)) {
                    errorLogger.addError(new EMJError(
                        "invalidBooleanOperand",
                        "Operand of AND must be of type BOOL, found: " + type,
                        ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }
            
            return hasTypeError ? "UNKNOWN" : "BOOL";
        }

        // Sinon, déléguer au premier notExpression
        return visit(ctx.notExpression(0));
    }

    /*@ requires ctx != null;
    @ ensures ctx.NOT() == null ==> \result == visit(ctx.comparisonExpression());
    @ ensures ctx.NOT() != null && visit(ctx.comparisonExpression()).equals("BOOLEAN") ==>
    @         \result.equals("BOOLEAN");
    @ assignable \nothing;
    @*/
    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // S'il y a un NOT, c'est un booléen
        if (ctx.NOT() != null) {
            String exprType = (String) visit(ctx.comparisonExpression());
            if (!"BOOL".equals(exprType) && !"UNKNOWN".equals(exprType)) {
                errorLogger.addError(new EMJError(
                    "invalidNotOperand",
                    "Operand of NOT must be of type BOOL, found: " + exprType,
                    ctx.start.getLine()
                ));
                return "UNKNOWN";
            }
            return "BOOL";
        }

        // Sinon, déléguer à comparisonExpression
        return visit(ctx.comparisonExpression());
    }

    /**
     * @requires ctx != null
     * @effects visite les expressions additives dans l'expression de comparaison
     *          vérifie que les opérandes des opérateurs de comparaison ont des types compatibles
     *          ajoute une erreur au errorLogger si les types sont incompatibles
     * @return le type de l'expression de comparaison:
     *         - le type de la sous-expression si c'est une expression simple
     *         - "BOOL" si c'est une comparaison avec des opérandes de types compatibles
     *         - "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // S'il y a un opérateur de comparaison, c'est un booléen
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null ||
                ctx.LESS() != null || ctx.LEQ() != null ||
                ctx.GREATER() != null || ctx.GEQ() != null) {
            // Récupérer les types des opérandes de la comparaison
            String leftType = (String) visit(ctx.additiveExpression(0));
            String rightType = (String) visit(ctx.additiveExpression(1));

            // Vérifier la compatibilité des types pour l'opération de comparaison
            if (!areComparisonTypesCompatible(leftType, rightType, ctx)) {
                // Ajouter une erreur sémantique si les types sont incompatibles
                errorLogger.addError(new EMJError(
                    "incompatibleComparisonTypes",
                    "Cannot compare values of incompatible types: '" + leftType + "' and '" + rightType + "'",
                    ctx.start.getLine()
                ));
                return "UNKNOWN"; // Retourner UNKNOWN au lieu de BOOL quand les types sont incompatibles
            }

            return "BOOL";
        }

        // Cas sans opérateur de comparaison, on envoie à la sous-expression unique
        return visit(ctx.additiveExpression(0));
    }



    /**
     * @requires ctx != null
     * @effects visite les expressions multiplicatives dans l'expression additive
     *          vérifie que les opérandes des opérateurs + et - sont de type INT
     *          ajoute une erreur au errorLogger si un opérande n'est pas de type INT
     * @return le type de l'expression additive:
     *         - le type de la sous-expression si c'est une expression simple
     *         - "INT" si tous les opérandes sont de type INT
     *         - "UNKNOWN" en cas d'erreur de type
     */
    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // On commence par le premier opérande
        Object leftObj = visit(ctx.multiplicativeExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";

        if (ctx.multiplicativeExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            Object rightObj = visit(ctx.multiplicativeExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Vérifie que les deux opérandes sont des entiers
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '+' or '-' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // Pour les itérations suivantes - ne pas forcer le type si erreur
            if (!hasTypeError) {
                leftType = "INT";
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }

    /*@ requires ctx != null;
       @ ensures ctx.unaryExpression().size() <= 1 ==> \result == visit(ctx.unaryExpression(0));
       @ ensures ctx.unaryExpression().size() > 1 && ctx.DIV() != null &&
       @         visit(ctx.unaryExpression(0)).equals("INT") &&
       @         visit(ctx.unaryExpression(1)).equals("INT") ==>
       @         \result.equals("INT");
       @ assignable \nothing;
       @*/
    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        Object leftObj = visit(ctx.unaryExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";
        if (ctx.unaryExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;
        
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            Object rightObj = visit(ctx.unaryExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Si l'un des opérandes a déjà une erreur de type, propager l'erreur
            if ("UNKNOWN".equals(leftType) || "UNKNOWN".equals(rightType)) {
                return "UNKNOWN";
            }

            // Vérification spécifique pour la division
            if (ctx.DIVIDE(i - 1) != null) {
                // Vérifier que les deux types sont INT
                if (!leftType.equals("INT") || !rightType.equals("INT")) {
                    // Cas spécial: division d'une chaîne par un nombre, erreur sémantique
                    if (leftType.equals("STRING") && rightType.equals("INT")) {
                        errorLogger.addError(new EMJError(
                                "invalidDivisionOperation",
                                "Cannot divide a STRING by an INT: '" + leftType + "' / '" + rightType + "'",
                                ctx.start.getLine()
                        ));

                    } else {
                        errorLogger.addError(new EMJError(
                                "invalidOperandType",
                                "Operands of '*' or '/' must be of type INT, found: " + leftType + " and " + rightType,
                                ctx.start.getLine()
                        ));
                    }
                    hasTypeError = true;
                }

                // Vérification de division par zéro
                EMJParser.UnaryExpressionContext rightExpr = ctx.unaryExpression(i);
                if (rightExpr.primaryExpression() != null && rightExpr.primaryExpression().INT_VALUE() != null) {
                    String valueText = rightExpr.primaryExpression().INT_VALUE().getText();
                    try {
                        int val = Integer.parseInt(valueText);
                        if (val == 0) {
                            errorLogger.addError(new EMJError(
                                    "divisionByZero",
                                    "Division by zero is not allowed.",
                                    ctx.start.getLine()
                            ));
                            hasTypeError = true;
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            } else {
                // Pour la multiplication, vérifier simplement que les deux types sont INT
                if (!leftType.equals("INT") || !rightType.equals("INT")) {
                    errorLogger.addError(new EMJError(
                            "invalidOperandType",
                            "Operands of '*' must be of type INT, found: " + leftType + " and " + rightType,
                            ctx.start.getLine()
                    ));
                    hasTypeError = true;
                }
            }

            // Ne pas forcer le type à INT si une erreur a été détectée
            if (!hasTypeError) {
                leftType = "INT"; 
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }

    /*@ requires ctx != null;
     @ ensures ctx.SUB() == null ==> \result == visit(ctx.primaryExpression());
     @ ensures ctx.SUB() != null && visit(ctx.primaryExpression()).equals("INT") ==>
     @         \result.equals("INT");
     @ assignable \nothing;
     @*/
    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // S'il y a un - unaire, c'est un entier
        if (ctx.MINUS() != null) {
            return "INT";
        }

        // Sinon, déléguer à primaryExpression
        return visit(ctx.primaryExpression());
    }

    /*@ requires ctx != null;
     @ ensures ctx.INT_LITERAL() != null ==> \result.equals("INT");
     @ ensures ctx.TRUE() != null || ctx.FALSE() != null ==> \result.equals("BOOLEAN");
     @ ensures ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null ==>
     @         \result.equals(symbolTable.lookup(ctx.EMOJI_ID().getText()).getType());
     @ ensures ctx.functionCall() != null ==> \result == visit(ctx.functionCall());
     @ ensures ctx.expression() != null ==> \result == visit(ctx.expression());
     @ assignable \nothing;
     @*/
    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        if (ctx.INT_VALUE() != null) {
            String intValue = ctx.INT_VALUE().getText();

            if (intValue.length() > 1 && intValue.charAt(0) == '0') {
                errorLogger.addError(new EMJError(
                        "intStartsWithZero",
                        "Integer value cannot start with 0: " + intValue,
                        ctx.start.getLine()));
            }

            try {
                long val = Long.parseLong(intValue);
                if (val > 1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooBig",
                            "Integer value too big: " + intValue,
                            ctx.start.getLine()));
                } else if (val < -1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooSmall",
                            "Integer value too small: " + intValue,
                            ctx.start.getLine()));
                }
            } catch (NumberFormatException e) {
                errorLogger.addError(new EMJError(
                        "invalidIntegerFormat",
                        "Invalid integer format: " + intValue,
                        ctx.start.getLine()));
            }
            return "INT";
        }

        if (ctx.STRING_VALUE() != null) return "STRING";
        if (ctx.CHAR_VALUE()   != null) return "CHAR";
        if (ctx.TRUE() != null || ctx.FALSE() != null) return "BOOL";

        if (ctx.tupleValue() != null) {
            String t1 = (String) visit(ctx.tupleValue().expression(0));
            String t2 = (String) visit(ctx.tupleValue().expression(1));
            if (!t1.equals(t2)) {
                errorLogger.addError(new EMJError(
                        "tupleMismatchedTypes",
                        "Tuple elements must have the same type, found: " + t1 + " and " + t2,
                        ctx.start.getLine()));
            }
            return "TUPLE(" + t1 + ")";
        }

        if (ctx.EMOJI_ID() != null) {
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        "Variable '" + varId + "' is not declared",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        "Variable '" + varId + "' is used before being initialized",
                        ctx.start.getLine()));
            }
            return info.getType();
        }

        if (ctx.leftExpression() != null) {
            EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
            String varId = leftCtx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        "Variable '" + varId + "' is not declared",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        "Tuple '" + varId + "' is used before being initialized",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            return getLeftExpressionType(leftCtx);
        }

        if (ctx.functionCall() != null) {
            return visitFunctionCall(ctx.functionCall());
        }

        if (ctx.expression() != null) {
            return visit(ctx.expression());
        }

        if (ctx.NOT() != null && ctx.primaryExpression() != null) {
            String t = (String) visit(ctx.primaryExpression());
            if (!"BOOL".equals(t)) {
                errorLogger.addError(new EMJError(
                        "invalidNegationOperand",
                        "Operand of NOT must be of type BOOL, found: " + t,
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            return "BOOL";
        }

        return "UNKNOWN";
    }

    /*@ requires ctx != null;
         @ ensures ctx.EMOJI_ID() != null && symbolTable.lookup(ctx.EMOJI_ID().getText()) != null ==>
         @         \result.equals(symbolTable.lookup(ctx.EMOJI_ID().getText()).getType());
         @ pure
         @*/
    // Méthode auxiliaire pour obtenir le type d'une expression gauche
    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        EMJSymbolInfo info = symbolTable.lookup(varId);

        if (info == null) {
            errorLogger.addError(new EMJError(
                    "undeclaredVariable",
                    "Variable '" + varId + "' is not declared",
                    ctx.getStart().getLine()
            ));
            return "UNKNOWN";
        }

        String varType = info.getType();

        // Si on accède à un élément d'un tuple
        if (ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null) {
            if (!varType.startsWith("TUPLE(")) {
                errorLogger.addError(new EMJError(
                        "invalidTupleAccess",
                        "Cannot access tuple element from non-tuple variable '" + varId + "'",
                        ctx.getStart().getLine()
                ));
                return "UNKNOWN";
            }

            // Extraire le type interne du tuple (ce qui est entre parenthèses)
            return varType.substring(6, varType.length() - 1);
        }

        return varType;
    }



    /*@ requires ctx != null;
      @ assignable \nothing;
      @*/ 
    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }

/*@ requires ctx != null;
      @ assignable \nothing;
      @*/
    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {

        symbolTable.enterScope("main");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    /*@ requires ctx != null;
    @ requires ctx.EMOJI_ID() != null;
    @ ensures symbolTable.functionExists(ctx.EMOJI_ID().getText());
    @ assignable \nothing;
    @*/
    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        // Récupérer l'identifiant de la fonction
        String funcId = ctx.EMOJI_ID().getText();

        // Récupérer le type de retour
        String returnType = getTypeFromContext(ctx.returnType());

        // Récupérer les paramètres
        List<EMJParameterInfo> parameters = new ArrayList<>();
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            EMJParser.ParamListContext paramListCtx = ctx.optionalParamList().paramList();
            for (EMJParser.ParamContext paramCtx : paramListCtx.param()) {
                String paramId = paramCtx.EMOJI_ID().getText();
                String paramType = getTypeFromContext(paramCtx.type());
                parameters.add(new EMJParameterInfo(paramId, paramType));
            }
        }

        // Vérifier si la fonction existe déjà
        if (symbolTable.functionExists(funcId)) {
            errorLogger.addError(new EMJError("functionAlreadyDefined",
                    "Function " + funcId + " is already defined", ctx.start.getLine()));
            return null;
        }

        // Ajouter la fonction à la table des symboles
        symbolTable.addFunction(funcId, returnType, parameters);

        // Entrer dans la portée de la fonction
        symbolTable.enterScope("function_" + funcId);

        // Ajouter les paramètres dans la portée de la fonction
        for (EMJParameterInfo param : parameters) {
            symbolTable.addVariable(param.getId(), param.getType(), true);
        }

        // Visiter le corps de la fonction
        Object result = visitChildren(ctx);

        // Sortir de la portée de la fonction
        symbolTable.exitScope();

        return result;
    }

    /*@ requires ctx != null;
    @ ensures \result != null;
    @ ensures ctx.INT_TYPE() != null ==> \result.equals("INT");
    @ ensures ctx.BOOLEAN_TYPE() != null ==> \result.equals("BOOLEAN");
    @ ensures ctx.VOID_TYPE() != null ==> \result.equals("VOID");
    @ pure
    @*/
    // Méthode auxiliaire pour obtenir le type à partir d'un contexte de type
    private String getTypeFromContext(EMJParser.ReturnTypeContext ctx) {
        if (ctx.VOID_TYPE() != null) {
            return "VOID";
        } else if (ctx.type() != null) {
            return getTypeFromContext(ctx.type());
        }
        return "UNKNOWN";
    }


    /*@ requires ctx != null;
   @ requires ctx.expression() != null;
   @ ensures getExpressionType(ctx.expression()).equals("BOOLEAN") ||
   @         errorLogger.hasErrors();
   @ assignable \nothing;
   @*/
    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {

        symbolTable.enterScope("loop");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {

        symbolTable.enterScope("if");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

      /*@ requires ctx != null;
      @ assignable \nothing;
      @*/
    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {

        symbolTable.enterScope("block");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }


    /*@ requires ctx != null;
    @ requires ctx.leftExpression() != null;
    @ requires ctx.expression() != null;
    @ ensures symbolTable.lookup(ctx.leftExpression().EMOJI_ID().getText()) != null ==>
    @         symbolTable.lookup(ctx.leftExpression().EMOJI_ID().getText()).isInitialized();
    @ assignable \nothing;
    @*/
    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
        String varId = leftCtx.EMOJI_ID().getText();

        EMJSymbolInfo varInfo = symbolTable.lookup(varId);
        if (varInfo == null) {
            errorLogger.addError(new EMJError(
                    "varIdNotDecl",
                    ctx.getText(),
                    ctx.start.getLine()));
            return null;
        }

        String leftType  = getLeftExpressionType(leftCtx);
        String rightType = getExpressionType(ctx.expression());

        if (!areTypesCompatible(leftType, rightType)) {
            errorLogger.addError(new EMJError(
                    "typeMismatch",
                    "Cannot assign value of type '" + rightType +
                            "' to target of type '" + leftType + "'",
                    ctx.start.getLine()));
            return null;
        }

        if (leftCtx.TUPLE_FIRST() == null && leftCtx.TUPLE_SECOND() == null) {
            varInfo.setInitialized(true);
        }

        return null;
    }

    /**
     * @requires ctx != null && ctx.EMOJI_ID() != null
     * @effects vérifie que la fonction appelée est déclarée dans la table des symboles
     *          vérifie que le nombre et les types des arguments correspondent aux paramètres déclarés
     *          vérifie que les fonctions void ne sont pas utilisées dans des expressions
     *          ajoute des erreurs au errorLogger si:
     *            - la fonction n'est pas déclarée
     *            - une fonction void est utilisée dans une expression
     *            - le nombre d'arguments ne correspond pas
     *            - les types des arguments sont incompatibles avec les types des paramètres
     * @return le type de retour de la fonction si elle est déclarée, "UNKNOWN" sinon
     */
    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String functionName = ctx.EMOJI_ID().getText(); // Retrieve the name of the called function

        // Retrieve the number of arguments passed to the function call
        List<EMJParser.ExpressionContext> args =
                ctx.argumentList() != null ? ctx.argumentList().expression() : new ArrayList<>();

        // Retrieve the function definition from the symbol table
        EMJSymbolInfo functionSymbol = symbolTable.lookup(functionName);

        if (functionSymbol == null || functionSymbol.getSymbolType() != EMJSymbolType.FUNCTION) {
            errorLogger.addError(new EMJError("Function not declared", functionName, ctx.getStart().getLine()));
            return "UNKNOWN";
        }

        // Vérifier si la fonction est de type void et si elle est appelée dans une expression
        if ("VOID".equals(functionSymbol.getReturnType())) {
            // Pour les fonctions void, vérifier si elles sont utilisées dans une expression
            // Nous considérons tout contexte autre qu'une instruction directe comme une expression
            boolean isUsedInExpression = true; // Par défaut, considérer comme utilisé dans une expression
            
            // Vérifier si l'appel est directement dans une instruction (statement)
            if (ctx.getParent() instanceof EMJParser.FunctionCallStmtContext) {
                isUsedInExpression = false;
            }

            if (isUsedInExpression) {
                // Ajouter une erreur sémantique pour l'utilisation d'une fonction void dans une expression
                errorLogger.addError(new EMJError(
                    "voidFunctionInExpression",
                    "Function " + functionName + " has void return type and cannot be used in an expression",
                    ctx.getStart().getLine()
                ));
            }
        }

        int expected = functionSymbol.getParameters() != null ? functionSymbol.getParameters().size() : 0;
        int actual = args.size();

        if (actual < expected) {
            errorLogger.addError(new EMJError("Too few parameters", functionName, ctx.getStart().getLine()));
        } else if (actual > expected) {
            errorLogger.addError(new EMJError("Too many parameters", functionName, ctx.getStart().getLine()));
        }

        // Visit each argument expression to perform semantic checks
        for (int i = 0; i < Math.min(actual, expected); i++) {
            String argType = (String) visit(args.get(i));
            if (functionSymbol.getParameters() != null && i < functionSymbol.getParameters().size()) {
                String paramType = functionSymbol.getParameters().get(i).getType();
                if (!areTypesCompatible(paramType, argType)) {
                    errorLogger.addError(new EMJError(
                        "paramTypeMismatch",
                        "Parameter " + (i+1) + " of function " + functionName + " expects type " + 
                        paramType + " but got " + argType,
                        ctx.getStart().getLine()
                    ));
                }
            }
        }

        // Return the function's return type
        return functionSymbol.getReturnType();
    }
}