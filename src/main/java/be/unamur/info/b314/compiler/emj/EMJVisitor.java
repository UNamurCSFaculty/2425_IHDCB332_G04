package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJParser;

import java.util.ArrayList;
import java.util.List;

/*
Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
@author : Alix Decrop
@version : 1.0
*/
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private final EMJErrorLogger errorLogger;
    private final EMJSymbolTable symbolTable;

    public EMJVisitor() {
        this.errorLogger = new EMJErrorLogger();
        this.symbolTable = new EMJSymbolTable();
    }


    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }

    /*
    SEMANTIC_VAR_DECL
    */
    @Override
    public Object visitProgramFile(EMJParser.ProgramFileContext ctx){
        for (EMJParser.FunctionDeclContext functionDeclContext : ctx.functionDecl()) {
            visitFunctionDecl(functionDeclContext);
        }
        visit(ctx.mainFunction());
        return null;
    }
    @Override
    public Object visitVarDecl(EMJParser.VarDeclContext ctx) {

        // SEMANTIC_CHECK_VAR_ID_ALREADY_EXISTS : Check if the id in the variable declaration does not exist yet
        String varId = ctx.EMOJI_ID().getText();

        // If variable id already exist in variables throw an error
        if(this.symbolTable.lookup(varId) != null) {
            this.errorLogger.addError(new EMJError("varIdAlreadyExists", ctx.getText(), ctx.start.getLine()));
        }

        String varType = getTypeFromContext(ctx.type());
        boolean isInitialized = ctx.expression() != null;
        this.symbolTable.addVariable(varId, varType, isInitialized);
        // Need to check type compatibility
        if (isInitialized) {
            // Visit the expression to determine its type
            String exprType = getExpressionType(ctx.expression());

            if (!areTypesCompatible(varType, exprType)) {
                this.errorLogger.addError(new EMJError(
                        "typeMismatch",
                        "Cannot initialize variable of type '" + varType +
                                "' with an expression of type '" + exprType + "'",
                        ctx.start.getLine()
                ));
            }
        }

        return null;
    }

    private boolean areTypesCompatible(String declaredType, String exprType) {
        if (declaredType == null || exprType == null || "UNKNOWN".equals(declaredType) || "UNKNOWN".equals(exprType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (declaredType.equals(exprType)) {
            return true;
        }

        // Si l'un est un tuple et l'autre ne l'est pas, ils sont incompatibles
        if (declaredType.startsWith("TUPLE(") && !exprType.startsWith("TUPLE(")) {
            return false;
        }

        if (!declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            return false;
        }

        // Pour deux tuples, vérifier la compatibilité des types internes
        if (declaredType.startsWith("TUPLE(") && exprType.startsWith("TUPLE(")) {
            String declaredInner = declaredType.substring(6, declaredType.length() - 1).trim();
            String exprInner = exprType.substring(6, exprType.length() - 1).trim();
            return areTypesCompatible(declaredInner, exprInner);
        }

        return false;
    }



    /**
     * Vérifie si les types sont compatibles pour une opération de comparaison
     * @param leftType Le type de l'expression gauche
     * @param rightType Le type de l'expression droite
     * @param ctx Le contexte de la comparaison
     * @return true si les types sont compatibles pour la comparaison, false sinon
     */
    private boolean areComparisonTypesCompatible(String leftType, String rightType, Object ctx) {
        // Si l'un des types est inconnu, considérer comme incompatible
        if (leftType == null || rightType == null || "UNKNOWN".equals(leftType) || "UNKNOWN".equals(rightType)) {
            return false;
        }

        // Si les types sont identiques, ils sont compatibles
        if (leftType.equals(rightType)) {
            return true;
        }

        // Pour les opérateurs ==, != seuls les types identiques sont compatibles
        if (ctx instanceof EMJParser.ComparisonExpressionContext) {
            EMJParser.ComparisonExpressionContext compCtx = (EMJParser.ComparisonExpressionContext) ctx;
            if (compCtx.DOUBLE_EQUAL() != null || compCtx.NOTEQUAL() != null) {
                // Pour ces opérateurs, les types doivent être identiques
                return false;
            }

            // Pour les opérateurs <, <=, >, >=, seuls les types numériques sont compatibles entre eux
            if (compCtx.LESS() != null || compCtx.LEQ() != null || compCtx.GREATER() != null || compCtx.GEQ() != null) {
                // Pour ces opérateurs, les deux opérandes doivent être des nombres
                return "INT".equals(leftType) && "INT".equals(rightType);
            }
        }

        // Par défaut, les types sont considérés comme incompatibles
        return false;
    }

    private String getTypeFromContext(EMJParser.TypeContext typeCtx) {
        if (typeCtx.INT_TYPE() != null) {
            return "INT";
        } else if (typeCtx.BOOL_TYPE() != null) {
            return "BOOL";
        } else if (typeCtx.CHAR_TYPE() != null) {
            return "CHAR";
        } else if (typeCtx.STRING_TYPE() != null) {
            return "STRING";
        } else if (typeCtx.tupleType() != null) {
            EMJParser.TupleTypeContext tupleCtx = typeCtx.tupleType();
            String innerType = getTypeFromContext(tupleCtx.type());
            return "TUPLE(" + innerType + ")";
        }
        return "UNKNOWN";
    }



    private String getExpressionType(EMJParser.ExpressionContext ctx) {
        // Visiter l'expression et récupérer le résultat
        Object result = visit(ctx);

        // Convertir le résultat en type
        if (result instanceof String) {
            return (String) result;
        }

        return "UNKNOWN";
    }

    // Override des méthodes de visite pour chaque type d'expression
    @Override
    public Object visitExpression(EMJParser.ExpressionContext ctx) {
        // Déléguer à la méthode de visite pour orExpression
        return visit(ctx.orExpression());
    }

    @Override
    public Object visitOrExpression(EMJParser.OrExpressionContext ctx) {
        // S'il y a plus d'une andExpression connectée par OR, c'est un booléen
        if (!ctx.OR().isEmpty()) {
            return "BOOL";
        }

        // Sinon, déléguer au premier andExpression
        return visit(ctx.andExpression(0));
    }

    @Override
    public Object visitAndExpression(EMJParser.AndExpressionContext ctx) {
        // S'il y a plus d'une notExpression connectée par AND, c'est un booléen
        if (!ctx.AND().isEmpty()) {
            return "BOOL";
        }

        // Sinon, déléguer au premier notExpression
        return visit(ctx.notExpression(0));
    }

    @Override
    public Object visitNotExpression(EMJParser.NotExpressionContext ctx) {
        // S'il y a un NOT, c'est un booléen
        if (ctx.NOT() != null) {
            return "BOOL";
        }

        // Sinon, déléguer à comparisonExpression
        return visit(ctx.comparisonExpression());
    }

    @Override
    public Object visitComparisonExpression(EMJParser.ComparisonExpressionContext ctx) {
        // S'il y a un opérateur de comparaison, c'est un booléen
        if (ctx.DOUBLE_EQUAL() != null || ctx.NOTEQUAL() != null ||
                ctx.LESS() != null || ctx.LEQ() != null ||
                ctx.GREATER() != null || ctx.GEQ() != null) {
            // Récupérer les types des opérandes de la comparaison
            String leftType = (String) visit(ctx.additiveExpression(0));
            String rightType = (String) visit(ctx.additiveExpression(1));

            // Vérifier la compatibilité des types pour l'opération de comparaison
            if (!areComparisonTypesCompatible(leftType, rightType, ctx)) {
                // Ajouter une erreur sémantique si les types sont incompatibles
                errorLogger.addError(new EMJError(
                    "incompatibleComparisonTypes",
                    "Cannot compare values of incompatible types: '" + leftType + "' and '" + rightType + "'",
                    ctx.start.getLine()
                ));
            }

            return "BOOL";
        }

        // Cas sans opérateur de comparaison, on envoie à la sous-expression unique
        return visit(ctx.additiveExpression(0));
    }



    @Override
    public Object visitAdditiveExpression(EMJParser.AdditiveExpressionContext ctx) {
        // On commence par le premier opérande
        Object leftObj = visit(ctx.multiplicativeExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";

        if (ctx.multiplicativeExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            Object rightObj = visit(ctx.multiplicativeExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Vérifie que les deux opérandes sont des entiers
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '+' or '-' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // Pour les itérations suivantes - ne pas forcer le type si erreur
            if (!hasTypeError) {
                leftType = "INT";
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }


    @Override
    public Object visitMultiplicativeExpression(EMJParser.MultiplicativeExpressionContext ctx) {
        Object leftObj = visit(ctx.unaryExpression(0));
        String leftType = (leftObj instanceof String) ? (String) leftObj : "UNKNOWN";
        if (ctx.unaryExpression().size() == 1) {
            return leftType;
        }
        
        boolean hasTypeError = false;
        
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            Object rightObj = visit(ctx.unaryExpression(i));
            String rightType = (rightObj instanceof String) ? (String) rightObj : "UNKNOWN";

            // Vérifie que les types sont bien INT
            if (!leftType.equals("INT") || !rightType.equals("INT")) {
                errorLogger.addError(new EMJError(
                        "invalidOperandType",
                        "Operands of '*' or '/' must be of type INT, found: " + leftType + " and " + rightType,
                        ctx.start.getLine()
                ));
                hasTypeError = true;
            }

            // Vérifie la division par zéro uniquement si la valeur est littérale
            if (ctx.DIVIDE(i - 1) != null) { // Vérifie si c'est un opérateur '/'
                EMJParser.UnaryExpressionContext rightExpr = ctx.unaryExpression(i);
                if (rightExpr.primaryExpression() != null && rightExpr.primaryExpression().INT_VALUE() != null) {
                    String valueText = rightExpr.primaryExpression().INT_VALUE().getText();
                    try {
                        int val = Integer.parseInt(valueText);
                        if (val == 0) {
                            errorLogger.addError(new EMJError(
                                    "divisionByZero",
                                    "Division by zero is not allowed.",
                                    ctx.start.getLine()
                            ));
                        }
                    } catch (NumberFormatException ignored) {
                    }
                }
            }

            // Ne pas forcer le type à INT si une erreur a été détectée
            if (!hasTypeError) {
                leftType = "INT"; 
            } else {
                leftType = "UNKNOWN";
            }
        }

        // Retourner UNKNOWN en cas d'erreur de type, sinon INT
        return hasTypeError ? "UNKNOWN" : "INT";
    }

    @Override
    public Object visitUnaryExpression(EMJParser.UnaryExpressionContext ctx) {
        // S'il y a un - unaire, c'est un entier
        if (ctx.MINUS() != null) {
            return "INT";
        }

        // Sinon, déléguer à primaryExpression
        return visit(ctx.primaryExpression());
    }

    @Override
    public Object visitPrimaryExpression(EMJParser.PrimaryExpressionContext ctx) {
        if (ctx.INT_VALUE() != null) {
            String intValue = ctx.INT_VALUE().getText();

            if (intValue.length() > 1 && intValue.charAt(0) == '0') {
                errorLogger.addError(new EMJError(
                        "intStartsWithZero",
                        "Integer value cannot start with 0: " + intValue,
                        ctx.start.getLine()));
            }

            try {
                long val = Long.parseLong(intValue);
                if (val > 1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooBig",
                            "Integer value too big: " + intValue,
                            ctx.start.getLine()));
                } else if (val < -1_000_000_000L) {
                    errorLogger.addError(new EMJError(
                            "integerTooSmall",
                            "Integer value too small: " + intValue,
                            ctx.start.getLine()));
                }
            } catch (NumberFormatException e) {
                errorLogger.addError(new EMJError(
                        "invalidIntegerFormat",
                        "Invalid integer format: " + intValue,
                        ctx.start.getLine()));
            }
            return "INT";
        }

        if (ctx.STRING_VALUE() != null) return "STRING";
        if (ctx.CHAR_VALUE()   != null) return "CHAR";
        if (ctx.TRUE() != null || ctx.FALSE() != null) return "BOOL";

        if (ctx.tupleValue() != null) {
            String t1 = (String) visit(ctx.tupleValue().expression(0));
            String t2 = (String) visit(ctx.tupleValue().expression(1));
            if (!t1.equals(t2)) {
                errorLogger.addError(new EMJError(
                        "tupleMismatchedTypes",
                        "Tuple elements must have the same type, found: " + t1 + " and " + t2,
                        ctx.start.getLine()));
            }
            return "TUPLE(" + t1 + ")";
        }

        if (ctx.EMOJI_ID() != null) {
            String varId = ctx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        "Variable '" + varId + "' is not declared",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        "Variable '" + varId + "' is used before being initialized",
                        ctx.start.getLine()));
            }
            return info.getType();
        }

        if (ctx.leftExpression() != null) {
            EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
            String varId = leftCtx.EMOJI_ID().getText();
            EMJSymbolInfo info = symbolTable.lookup(varId);

            if (info == null) {
                errorLogger.addError(new EMJError(
                        "undeclaredVariable",
                        "Variable '" + varId + "' is not declared",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            if (!info.isInitialized()) {
                errorLogger.addError(new EMJError(
                        "uninitializedVariable",
                        "Tuple '" + varId + "' is used before being initialized",
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            return getLeftExpressionType(leftCtx);
        }

        if (ctx.functionCall() != null) {
            return visitFunctionCall(ctx.functionCall());
        }

        if (ctx.expression() != null) {
            return visit(ctx.expression());
        }

        if (ctx.NOT() != null && ctx.primaryExpression() != null) {
            String t = (String) visit(ctx.primaryExpression());
            if (!"BOOL".equals(t)) {
                errorLogger.addError(new EMJError(
                        "invalidNegationOperand",
                        "Operand of NOT must be of type BOOL, found: " + t,
                        ctx.start.getLine()));
                return "UNKNOWN";
            }
            return "BOOL";
        }

        return "UNKNOWN";
    }

    // Méthode auxiliaire pour obtenir le type d'une expression gauche
    private String getLeftExpressionType(EMJParser.LeftExpressionContext ctx) {
        String varId = ctx.EMOJI_ID().getText();
        EMJSymbolInfo info = symbolTable.lookup(varId);

        if (info == null) {
            errorLogger.addError(new EMJError(
                    "undeclaredVariable",
                    "Variable '" + varId + "' is not declared",
                    ctx.getStart().getLine()
            ));
            return "UNKNOWN";
        }

        String varType = info.getType();

        // Si on accède à un élément d'un tuple
        if (ctx.TUPLE_FIRST() != null || ctx.TUPLE_SECOND() != null) {
            if (!varType.startsWith("TUPLE(")) {
                errorLogger.addError(new EMJError(
                        "invalidTupleAccess",
                        "Cannot access tuple element from non-tuple variable '" + varId + "'",
                        ctx.getStart().getLine()
                ));
                return "UNKNOWN";
            }

            // Extraire le type interne du tuple (ce qui est entre parenthèses)
            return varType.substring(6, varType.length() - 1);
        }

        return varType;
    }



    @Override
    public Object visitMapFile(EMJParser.MapFileContext ctx) {
        int width = Integer.parseInt(ctx.INT_VALUE(0).getText());
        int height = Integer.parseInt(ctx.INT_VALUE(1).getText());
        int policeCarCount = 0;
        int thiefCount = 0;
        int roadCount = 0;
        int expectedCellCount = width * height;
        int actualCellCount = ctx.mapCell().size();

        if (width < 2 || height < 2) {
            this.errorLogger.addError(new EMJError(
                    "mapTooSmall",
                    "The map must at least have a width >= 2 and a height >= 2 (current : " + width + "x" + height + ").",
                    ctx.start.getLine()
            ));
        }

        if (expectedCellCount != actualCellCount) {
            this.errorLogger.addError(new EMJError(
                    "mapDimensionsMismatch",
                    "The size given (" + width + "x" + height + " = " + expectedCellCount + " cells) don't match with the number of cells given (" + actualCellCount + ").",
                    ctx.start.getLine()
            ));
        }



        for (EMJParser.MapCellContext cellCtx : ctx.mapCell()) {
            if (cellCtx.COP() != null) {
                policeCarCount++;
            }
            if (cellCtx.THIEF() != null) {
                thiefCount++;
            }
            if (cellCtx.ROAD() != null) {
                roadCount++;
            }
        }

        if (policeCarCount != 1) {
            this.errorLogger.addError(new EMJError(
                    "mapPoliceCarCountInvalid",
                    "The map must contain exactly 1 Police Car, found : " + policeCarCount,
                    ctx.start.getLine()
            ));
        }

        if (thiefCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapThiefMissing",
                    "The map must contain at least 1 Thief, found : " + thiefCount,
                    ctx.start.getLine()
            ));
        }

        if (roadCount < 1) {
            this.errorLogger.addError(new EMJError(
                    "mapRoadMissing",
                    "The map must contain at least 1 Road, found : " + roadCount,
                    ctx.start.getLine()
            ));
        }

        return null;
    }


    @Override
    public Object visitMainFunction(EMJParser.MainFunctionContext ctx) {

        symbolTable.enterScope("main");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitFunctionDecl(EMJParser.FunctionDeclContext ctx) {
        // Récupérer l'identifiant de la fonction
        String funcId = ctx.EMOJI_ID().getText();

        // Récupérer le type de retour
        String returnType = getTypeFromContext(ctx.returnType());

        // Récupérer les paramètres
        List<EMJParameterInfo> parameters = new ArrayList<>();
        if (ctx.optionalParamList() != null && ctx.optionalParamList().paramList() != null) {
            EMJParser.ParamListContext paramListCtx = ctx.optionalParamList().paramList();
            for (EMJParser.ParamContext paramCtx : paramListCtx.param()) {
                String paramId = paramCtx.EMOJI_ID().getText();
                String paramType = getTypeFromContext(paramCtx.type());
                parameters.add(new EMJParameterInfo(paramId, paramType));
            }
        }

        // Vérifier si la fonction existe déjà
        if (symbolTable.functionExists(funcId)) {
            errorLogger.addError(new EMJError("functionAlreadyDefined",
                    "Function " + funcId + " is already defined", ctx.start.getLine()));
            return null;
        }

        // Ajouter la fonction à la table des symboles
        symbolTable.addFunction(funcId, returnType, parameters);

        // Entrer dans la portée de la fonction
        symbolTable.enterScope("function_" + funcId);

        // Ajouter les paramètres dans la portée de la fonction
        for (EMJParameterInfo param : parameters) {
            symbolTable.addVariable(param.getId(), param.getType(), true);
        }

        // Visiter le corps de la fonction
        Object result = visitChildren(ctx);

        // Sortir de la portée de la fonction
        symbolTable.exitScope();

        return result;
    }

    // Méthode auxiliaire pour obtenir le type à partir d'un contexte de type
    private String getTypeFromContext(EMJParser.ReturnTypeContext ctx) {
        if (ctx.VOID_TYPE() != null) {
            return "VOID";
        } else if (ctx.type() != null) {
            return getTypeFromContext(ctx.type());
        }
        return "UNKNOWN";
    }


    @Override
    public Object visitLoopStatement(EMJParser.LoopStatementContext ctx) {

        symbolTable.enterScope("loop");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitIfStatement(EMJParser.IfStatementContext ctx) {

        symbolTable.enterScope("if");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }

    @Override
    public Object visitBlock(EMJParser.BlockContext ctx) {

        symbolTable.enterScope("block");
        Object result = visitChildren(ctx);
        symbolTable.exitScope();
        return result;
    }


    @Override
    public Object visitAssignment(EMJParser.AssignmentContext ctx) {
        EMJParser.LeftExpressionContext leftCtx = ctx.leftExpression();
        String varId = leftCtx.EMOJI_ID().getText();

        EMJSymbolInfo varInfo = symbolTable.lookup(varId);
        if (varInfo == null) {
            errorLogger.addError(new EMJError(
                    "varIdNotDecl",
                    ctx.getText(),
                    ctx.start.getLine()));
            return null;
        }

        String leftType  = getLeftExpressionType(leftCtx);
        String rightType = getExpressionType(ctx.expression());

        if (!areTypesCompatible(leftType, rightType)) {
            errorLogger.addError(new EMJError(
                    "typeMismatch",
                    "Cannot assign value of type '" + rightType +
                            "' to target of type '" + leftType + "'",
                    ctx.start.getLine()));
            return null;
        }

        if (leftCtx.TUPLE_FIRST() == null && leftCtx.TUPLE_SECOND() == null) {
            varInfo.setInitialized(true);
        }

        return null;
    }

    @Override
    public Object visitFunctionCall(EMJParser.FunctionCallContext ctx) {
        String functionName = ctx.EMOJI_ID().getText(); // Retrieve the name of the called function

        // Retrieve the number of arguments passed to the function call
        List<EMJParser.ExpressionContext> args =
                ctx.argumentList() != null ? ctx.argumentList().expression() : new ArrayList<>();

        // Retrieve the function definition from the symbol table
        EMJSymbolInfo functionSymbol = symbolTable.lookup(functionName);

        if (functionSymbol == null || functionSymbol.getSymbolType() != EMJSymbolType.FUNCTION) {
            errorLogger.addError(new EMJError("Function not declared", functionName, ctx.getStart().getLine()));
            return "UNKNOWN";
        }

        // Vérifier si la fonction est de type void et si elle est appelée dans une expression
        if ("VOID".equals(functionSymbol.getReturnType())) {
            // Pour les fonctions void, vérifier si elles sont utilisées dans une expression
            // Nous considérons tout contexte autre qu'une instruction directe comme une expression
            boolean isUsedInExpression = true; // Par défaut, considérer comme utilisé dans une expression
            
            // Vérifier si l'appel est directement dans une instruction (statement)
            if (ctx.getParent() instanceof EMJParser.FunctionCallStmtContext) {
                isUsedInExpression = false;
            }

            if (isUsedInExpression) {
                // Ajouter une erreur sémantique pour l'utilisation d'une fonction void dans une expression
                errorLogger.addError(new EMJError(
                    "voidFunctionInExpression",
                    "Function " + functionName + " has void return type and cannot be used in an expression",
                    ctx.getStart().getLine()
                ));
            }
        }

        int expected = functionSymbol.getParameters() != null ? functionSymbol.getParameters().size() : 0;
        int actual = args.size();

        if (actual < expected) {
            errorLogger.addError(new EMJError("Too few parameters", functionName, ctx.getStart().getLine()));
        } else if (actual > expected) {
            errorLogger.addError(new EMJError("Too many parameters", functionName, ctx.getStart().getLine()));
        }

        // Visit each argument expression to perform semantic checks
        for (int i = 0; i < Math.min(actual, expected); i++) {
            String argType = (String) visit(args.get(i));
            if (functionSymbol.getParameters() != null && i < functionSymbol.getParameters().size()) {
                String paramType = functionSymbol.getParameters().get(i).getType();
                if (!areTypesCompatible(paramType, argType)) {
                    errorLogger.addError(new EMJError(
                        "paramTypeMismatch",
                        "Parameter " + (i+1) + " of function " + functionName + " expects type " + 
                        paramType + " but got " + argType,
                        ctx.getStart().getLine()
                    ));
                }
            }
        }

        // Return the function's return type
        return functionSymbol.getReturnType();
    }
}